Python para Cincia de datos
Hola, sean bienvenidos a un nuevo entrenamiento en la plataforma Alura Latam. Mi nombre es Álvaro Camacho y seré su instructor en este entrenamiento de Python para Data Science, primeros pasos. Antes de continuar con mi presentación, haré una breve autodescripción por motivos de accesibilidad. Soy hombre, tengo cabello castaño, piel blanca, llevo una camiseta naranja y estoy en uno de los estudios de Alura Latam, con fondo azul y verde.

En este curso, como bien indica el nombre, estarás dando los primeros pasos en Data Science. Si nunca has visto Python, si no conoces el lenguaje, si es la primera vez que vas a tener contacto con este lenguaje de programación tan fascinante, este curso es para ti. Si ya conoces algo de Python, entonces, seguramente, este curso será bastante introductorio. Por lo tanto, te aviso de una vez, en caso de que vayas a iniciar, para que, de repente, a lo largo del curso, no te sientas como si faltara algo.

Realmente, este curso tiene ese enfoque de que todas aquellas personas que desean aprender Data Science desde cero, utilizando Python, puedan hacerlo por medio de este entrenamiento.

En este curso, estaremos trabajando con Python Interactivo a través de la plataforma que nos ofrece Google Colab. De la misma forma, estaremos aprendiendo a trabajar desde lo más simple en el lenguaje de programación con Python, hasta algunas estructuras un poco más elaboradas, conocidas como colecciones, muy utilizadas en el área de ciencia de datos.

A lo largo del entrenamiento, estarás viendo este paso a paso, conociendo también algunos aspectos de lógica de programación que tal vez no conozcas. Y, adicionalmente, tras realizar este entrenamiento, tendrás algunas competencias iniciales para el uso de este tipo de lenguaje.

Te invito a que también compartas en redes sociales tu progreso, de la misma forma que evalúes el contenido del curso, para que de esta forma, continuamente, podamos mejorar y siempre dar lo mejor a nuestros estudiantes.

Por lo tanto, te invito a que prepares tu ambiente y comencemos a trabajar.

 Discutir en el Foro
*************************************************************************
02
Para saber más: ¿Qué es Python?
 Siguiente pregunta

Python es un lenguaje de programación de alto nivel, interpretado y orientado a objetos. Fue creado a finales de 1989 por el programador holandés Guido van Rossum. El nombre "Python" se inspiró en la serie de televisión británica Monty Python's Flying Circus y tiene como símbolo la imagen que se muestra a continuación:

2.gif

Python se utiliza en diversas áreas, como el desarrollo de aplicaciones web, la ciencia de datos, el aprendizaje automático, la automatización de tareas, el análisis de datos y muchas otras. Es un lenguaje de programación versátil que se puede utilizar para crear prácticamente cualquier tipo de programa.

Debido a su sintaxis simple y fácil de leer, se convierte en una buena elección para principiantes en la programación. Además, Python es uno de los lenguajes más utilizados en el mundo, con una gran comunidad activa y muchas bibliotecas y frameworks disponibles, lo que facilita la realización de diversas tareas.

Es compatible con varios sistemas operativos, como Windows, Linux y macOS. Como es un lenguaje popular y en constante evolución, Python se utiliza en muchas empresas y organizaciones en todo el mundo. También se utiliza ampliamente en aplicaciones científicas debido a su capacidad para manejar grandes conjuntos de datos y operaciones matemáticas complejas.

La información y la documentación sobre Python se pueden encontrar en el sitio web oficial
*****************************************************
03
Preparando el ambiente
 Siguiente pregunta

Vamos a acceder al notebook:

https://github.com/alura-es-cursos/python-para-datascience-primeros-pasos/blob/main/Python_Data_Science.ipynb

 que será utilizado durante el curso directamente desde github. Una vez accedes al github has clic sobre el siguiente botón para que lo puedas abrir directamente en tu cuenta de Colab:

1.jpg

Como lo acabamos de mencionar, nuestro ambiente de trabajo será Google Colaboratory:

https://colab.research.google.com/?hl=es-ES

Para lograr acceder a este, es necesario tener una cuenta en Gmail, dado que el notebook quedará almacenado en Google Drive.
*********************************************************************************
04
Google Colaboratory
Python para Data Science, se introduce el lenguaje de programación Python, que es multiparadigma y fue creado por Guido Van Rossum en los años 90. Se explica la diferencia entre lenguajes compilados e interpretados, usando la analogía de traducir una receta de cocina. Python es un lenguaje interpretado, lo que permite realizar correcciones rápidamente en el código.

Se destaca que Python tiene una sintaxis simple y es ideal para trabajar en Data Science. Además, se presenta Google Colaboratory (Google Colab) como una herramienta interactiva para programar en Python sin necesidad de instalar nada en la computadora. Se explica cómo acceder a Google Colab, cómo crear y manejar cuadernos (notebooks) con la extensión IPYNB, y se mencionan las opciones disponibles en la interfaz, como insertar celdas de código y texto, así como atajos de teclado para facilitar el trabajo.

Finalmente, se invita a los estudiantes a familiarizarse con el entorno de Google Colab antes de comenzar a codificar en Python en la próxima clase.
********************************************************************************************+
05
Para saber más: ¿Qué es Google Colaboratory?
 Siguiente pregunta

Google Colab es una herramienta que permite escribir y ejecutar código en Python a través de un navegador, sin necesidad de instalar ningún software adicional. Funciona mediante el uso de una máquina virtual, que es esencialmente un sistema virtual que simula una computadora.

Cuando creamos, cargamos o subimos un nuevo documento en Colab, estamos creando una máquina virtual que se ejecuta en uno de los servidores de Google. Esta máquina virtual tiene acceso a una serie de recursos, como CPU, memoria y almacenamiento, que se utilizan para ejecutar el código.

Es importante destacar que esta máquina virtual es temporal, lo que significa que se crea cuando abrimos Colab y se cierra cuando lo cerramos o cuando expira el tiempo de ejecución de la máquina. Esto significa que cualquier dato que carguemos en la máquina virtual se perderá cuando se cierre.

Puedes darte cuenta de que tu máquina virtual se ha cerrado cuando el indicador de conexión en la esquina superior derecha está en espera para conectarse, como se muestra en la imagen a continuación:

3.jpg

Para volver a conectar la máquina, simplemente haz clic en el botón "Conectar" y espera a que se establezca una nueva conexión. También es necesario ejecutar todas las celdas de creación y manipulación de variables que se crearon y ejecutaron antes de que la máquina virtual se cerrara, para que puedan ser utilizadas.
*************************************************************************+
06 Hola Mundo
Entorno de Python en Colab y se enseñó cómo ejecutar celdas de código. Se explicaron dos métodos para ejecutar celdas: Shift + Enter, que ejecuta y añade una nueva celda, y Ctrl + Enter, que solo ejecuta sin añadir una nueva celda.

Se introdujo la función print, que es una función incorporada en Python para mostrar texto en la salida. Se destacó la facilidad de uso de Python, ya que imprimir "Hola, mundo" requiere solo una línea de código, en comparación con otros lenguajes que pueden necesitar más líneas. También se mencionó que se pueden usar comillas simples o dobles para definir texto.

Se mostró cómo ejecutar diferentes comandos y se anticipó que en la próxima clase se abordaría la manipulación de datos y el concepto de variables.
***************************************************************************+ 	
07
¿Qué hace la función print()?
 Siguiente pregunta

Aprendimos sobre una de las funciones de Python: La función print(). Selecciona la alternativa que describe lo que esta función hace y muestra un ejemplo usando su sintaxis.

Alternativa correta
La función print imprime un contenido especificado por el programador. Un ejemplo de uso de esta función es el siguiente código: print(¡Hola mundo!)


Alternativa correta
La función print se utiliza para mostrar información en la pantalla, es decir, imprime o muestra el contenido pasado como argumento. Un ejemplo de uso de esta función es el siguiente código: print('¡Hola, mundo!')


La función print es una de las más útiles en el desarrollo de programas en Python, ya que permite ver lo que está sucediendo en su programa y ayuda a encontrar errores. Su sintaxis es simple: escribimos print seguido de paréntesis () y dentro de ellos ponemos lo que deseamos imprimir, como se muestra en la alternativa.

Alternativa correta
La función print se utiliza para escribir el contenido pasado como argumento en un archivo de texto en el sistema de archivos de la máquina. Un ejemplo de uso de esta función es el siguiente código: print('¡Hola, mundo!')
********************************************************************
08
Desafío: ¡Es hora de practicar!
 Siguiente pregunta

Vamos a practicar el uso de la función print con algunas actividades. Para ello, resuelve los problemas propuestos en código:

1 - Imprime la frase "Escuela de Datos de Alura".

2 - Imprime tu nombre y tu apellido siguiendo la estructura a continuación:

Nombre: [tu nombre]
Apellido: [tu apellido]
Copia el código
3 - Imprime tu primer nombre letra por letra. Por ejemplo, si mi nombre es Álvaro, la salida sería:

Á
L
V
A
R
O
Copia el código
4 - Imprime tu fecha de nacimiento en formato día mes año. Recuerda que los valores de día y año no deben estar entre comillas. Suponiendo una fecha de cumpleaños el 28 de febrero de 2003, el formato debe ser como el siguiente:

28 febrero 2003
Copia el código
5 - Imprime, en una sola instrucción print, el año actual en el que estás realizando este curso. El valor del año debe ser un dato numérico, y la salida de print debe ser la siguiente:

Año actual: [año]
Copia el código
Si necesitas ayuda, las soluciones a las actividades están disponibles en la sección "Opinión del instructor".
	
Opinión del instructor

Pueden existir varias formas de resolver los problemas propuestos, y algunas de ellas se presentan a continuación.

Para imprimir la frase "Escuela de Datos de Alura", usamos la función print y colocamos el texto entre comillas simples dentro de los paréntesis:

print('Escuela de Datos de Alura')
Copia el código
Cuando colocamos dos impresiones (print) en secuencia (una debajo de la otra), podemos obtener un salto de línea. Por lo tanto, el resultado esperado se puede obtener de la siguiente manera:

print('Nombre: <tu nombre>')
print('Apellido: <tu apellido>')
Siguiendo la misma lógica del ejercicio anterior, podemos separar líneas utilizando varias impresiones (print):
Copia el código
print('Á')
print('L')
print('V')
print('A')
print('R')
print('O')
Copia el código
Podemos combinar datos numéricos y textuales separándolos por comas. Así, podemos imprimir el día 28, seguido de una coma, luego el mes entre comillas 'febrero', otra coma y, finalmente, el año en formato numérico 2003:

print(28, 'febrero', 2003)
Copia el código
Con el mismo razonamiento que en la pregunta anterior, es posible imprimir datos numéricos y textuales separándolos por comas. De esta manera, podemos imprimir la frase 'Año actual:' y el año actual dentro de la función print, separándolos por una coma. Suponiendo que estemos tomando este curso en el año 2023, la solución sería la siguiente:

print('Año actual: ', 2023)
Copia el código
Es importante practicar para consolidar el contenido, desarrollar habilidades de codificación, identificar puntos que aún no se comprenden, prepararse para desafíos futuros y desarrollar el pensamiento lógico y la resolución de problemas.

Por lo tanto, es importante realizar muchos ejercicios cuando se está aprendiendo un nuevo lenguaje de programación. Así que busca practicar a través de los ejercicios propuestos y observa cómo te pueden ayudar a mejorar tus habilidades de codificación.

Si tienes alguna pregunta, utiliza el foro o nuestra comunidad en Discord.
********************************************************************************+
09
Lo que aprendimos
 Siguiente pregunta

Lo que aprendimos en esta aula:

Utilizar Google Colab para proyectos en Python.
Aplicar la función print para imprimir resultados en la pantalla.
Comprender qué es Python y conocer su historia.
****************************************************************++
01
Proyecto del aula anterior
 Siguiente pregunta

¿Comenzando en esta etapa? Aquí puedes descargar los archivos del proyecto que hemos avanzado hasta el aula anterior.

Descargue los archivos en Github o haga clic aquí para descargarlos directamente.

En mi Escritorio tengo este archivo inicial de Py con DC
C:\Users\Stolaba\Desktop\One-Alura-Oracle\001 DATA-SCIENCE

https://github.com/alura-es-cursos/python-para-datascience-primeros-pasos/blob/aula-2/Python_Data_Science.ipynb

********************************************************************************************************************
02 Variables
 variables en Python, explicando que una variable es un nombre que se asocia a un valor en la memoria. Se comparó el uso de variables en programación con el uso de letras en álgebra, donde una letra puede representar diferentes valores.

Se destacó la función id, que permite conocer la dirección de memoria de un objeto, y se mostró cómo al asignar un valor a una variable, esta puede apuntar al mismo espacio de memoria que otros valores. También se discutieron las reglas para nombrar variables, como no comenzar con números, no usar espacios y evitar palabras reservadas de Python.

Finalmente, se mencionó que Python permite la asignación dinámica de variables, lo que facilita su uso en comparación con otros lenguajes de programación. La clase concluyó con la expectativa de aprender más sobre los tipos de variables en la próxima lección.
************************************************************************************
03
Para saber más: comentarios
 Siguiente pregunta

A veces, cuando estamos programando, necesitamos describir alguna etapa, función o estructura dentro del propio código. Esta descripción debe darse como una anotación y, por lo tanto, no se considera código que se interprete en el entorno. Para estas situaciones, existen los comentarios.

Los comentarios son líneas de texto que se pueden colocar dentro del código y que son ignoradas por el intérprete. Por eso, sirven para explicar el funcionamiento del código a otras personas o incluso a la persona que programa. Son importantes para documentar el código, describiendo lo que hace y para qué sirve cada función, estructura o método. Esto puede hacer que el código sea más legible y fácil de entender.

Podemos construir dos tipos de comentarios en Python, de una y varias líneas.

Comentarios de una línea:

Estos comentarios se hacen agregando un símbolo de almohadilla/numeral (#) al principio de una línea de código. Todo lo que venga después del símbolo # en una línea se considerará un comentario, como se puede ver en el código a continuación:

# Este es un comentario de una línea
print(10) # Podemos colocar otro comentario en una línea después de un código
Copia el código
Puedes ejecutar el código anterior en tu cuaderno y verás que todo el texto después del símbolo # se ignora durante la ejecución.

Comentarios de varias líneas:

Los comentarios de varias líneas se hacen usando un conjunto de comillas triples: ''' o """. Todo lo que esté entre estas comillas triples se considerará un comentario, incluso si abarca varias líneas. Por ejemplo:

'''
Este es un comentario
de varias líneas.
'''
Copia el código
Mientras el texto esté dentro de las comillas, se ignorará durante la ejecución, ya sea en una línea de código o en cualquier otro texto. A pesar de estas formas de comentar el código, cuando trabajamos con un cuaderno de Python, tenemos la opción de crear celdas de texto en formato markdown.

Markdown:

Markdown es una forma de formato de texto que permite escribir de manera simple y fácil de leer. Permite agregar formato al texto sin necesidad de escribir código HTML u otro lenguaje de formato más complejo.

Con markdown, podemos formatear el texto para agregar negritas, cursivas, listas, encabezados, etc. Además, es una excelente opción para documentar el código describiendo lo que hemos hecho, analizando los resultados y proporcionando pasos futuros. En Ciencia de Datos, se hace un amplio uso de textos en markdown, ya que facilita en gran medida la documentación en cuadernos.

Para crear una celda de texto en Google Colab, puedes hacer clic en el botón + Texto debajo de la barra superior de botones de Colab, como se muestra en la imagen a continuación:

4.jpg

Al crear la celda de texto, puedes agregar el contenido que desees. El cuaderno de este curso está lleno de celdas de texto que explican varios aspectos de la programación en Python, todas formateadas con markdown. A continuación, te damos algunos consejos para construir texto con markdown:

Encabezados:

Para construir encabezados, puedes usar el símbolo # antes del texto. Cuantos más símbolos # uses, menor será el nivel del encabezado. Por ejemplo:

# Encabezado de nivel 1
## Encabezado de nivel 2
### Encabezado de nivel 3
Copia el código
Negritas e itálicas:

Para formatear el texto en negritas, puedes usar ** antes y después del texto, como en el ejemplo:

**Texto en negritas**
Copia el código
Para formatear el texto en cursiva, utiliza * antes y después del texto. Por ejemplo:

*Texto en cursiva*
Copia el código
También puedes combinar ambas formas de escritura agrupando las dos estructuras con ** y *. Por ejemplo:

***Texto en negritas y cursiva***
Copia el código
Listas:

Para crear listas no numeradas (con viñetas), coloca * y luego un espacio * antes del elemento, como en el ejemplo:

* Elemento 1
* Elemento 2
* Elemento 3
Copia el código
Para crear listas numeradas, puedes usar un número seguido de un punto y un espacio 1. antes del elemento, como en el ejemplo:

1. Elemento 1
2. Elemento 2
3. Elemento 3
Copia el código
Enlaces:

Para crear enlaces, a continuación, tienes un ejemplo con el enlace al sitio web de Alura:

[Página de Alura](https://www.aluracursos.com/)
Copia el código
Estos son ejemplos más comunes de uso de markdown, pero existen muchas otras formas y recursos disponibles para que domines el lenguaje de marcación.

 Discutir en el Foro
********************************************************************************+
04
Tipos de variables
En esta clase, se abordaron los tipos de variables en Python, fundamentales para la manipulación de datos en el contexto de la ciencia de datos. Se explicaron cuatro tipos principales de variables:

Enteros (int): Representan números enteros. Por ejemplo, se puede declarar una variable edad y asignarle un valor como 5.

Flotantes (float): Representan números decimales. Se utiliza el punto para separar la parte entera de la decimal, como en promedio = 9.5.

Cadenas de caracteres (string): Se utilizan para almacenar texto, que se puede definir usando comillas simples o dobles, como nombre = "Penelope".

Booleanos (bool): Representan valores de verdad, es decir, True o False. Por ejemplo, aprobada = True.

Se presentó un ejemplo práctico utilizando una estudiante llamada Penelope Camacho, donde se definieron variables para su nombre, edad, promedio y situación académica. Finalmente, se mostró cómo imprimir estas variables y verificar su tipo utilizando la función type(). La clase concluyó mencionando que en la próxima sesión se explorarán más operaciones con variables numéricas.
******************************************************************************
05 Variables numéricas
manipulación de variables numéricas en Python, enfocándonos en los tipos int y float. Utilizamos un ejemplo relacionado con una institución educativa, donde definimos variables para la cantidad y salario de vigilantes, docentes y coordinadores.

Definición de Variables: Creamos variables para la cantidad de empleados (Cvigilante, Cdocente, Ccoordinador) y sus respectivos salarios (Svigilante, Sdocente, Scoordinador).

Cálculo del Total de Empleados: Sumamos la cantidad de vigilantes, docentes y coordinadores para obtener el total de empleados, almacenándolo en la variable TotalEmpleados.

Diferencia de Salarios: Calculamos la diferencia entre el salario más alto (coordinador) y el más bajo (vigilante), guardando el resultado en diferencia_salario.

Promedio Ponderado de Salarios: Aprendimos a calcular el promedio ponderado de los salarios multiplicando la cantidad de empleados por sus respectivos salarios, sumando esos valores y dividiendo entre el total de empleados. El resultado se almacenó en promedio_salarios.

Tipos de Datos: Finalmente, revisamos los tipos de datos de las variables, donde TotalEmpleados es de tipo int y promedio_salarios es de tipo float.

Esta clase nos proporcionó una base sólida para trabajar con variables numéricas en Python y realizar cálculos básicos.
******************************************************************************
06
Para saber más: ¿Qué es la documentación?
 Siguiente pregunta

La documentación de cualquier lenguaje funciona como un conjunto de guías escritas para ayudar a los desarrolladores a comprender y utilizar un lenguaje de programación. Pueden encontrarse en sitios web creados por el equipo que desarrolló ese lenguaje. Como se mencionó en clase, podemos encontrar la documentación de Python en python.org.

https://wiki.python.org/moin/SpanishLanguage

Estas documentaciones suelen incluir información sobre sintaxis y estructuras, bibliotecas y herramientas disponibles, funciones, ejemplos de código y otros puntos útiles para ayudar a escribir código eficiente y correcto. Se trata de un recurso valioso tanto para quienes están aprendiendo un nuevo lenguaje de programación como para personas experimentadas que buscan información específica para su código.

Un detalle a tener en cuenta es que la mayoría de las documentaciones están escritas en inglés, lo que puede dificultar para alguien que no tiene un gran conocimiento de ese idioma. Sin embargo, normalmente hay soporte para la traducción al español a través del traductor del navegador.
*******************************************************************************
07
¿Para qué usar la función type()?
 Siguiente pregunta

La función type() de Python se puede utilizar para verificar los tipos de datos de una variable, lo que puede ser muy útil en Data Science para asegurarse de que los datos se procesen correctamente y para identificar posibles errores. Sabiendo esto, marca la alternativa que indica un ejemplo de uso de la función type.

Alternativa correta
Usamos type() para verificar el tipo de dato de una variable cuando es una función, con el objetivo de descubrir qué función se ha asignado y qué hace. En el siguiente ejemplo, intentamos descubrir qué hace la función print:

dato = print
type(dato)

Alternativa correta
La función type() puede ser útil para verificar el tipo de dato de una variable y determinar la mejor forma de manipular o procesar los datos. Para trabajar con estadísticas en datos financieros, por ejemplo, podemos verificar si los datos que tenemos son valores numéricos utilizando type.


Esta función devuelve una clase que representa el tipo del objeto pasado como argumento. De esta manera, podemos usar type para comprender el tipo de dato que tenemos y ajustarlo según las necesidades de un análisis.

Alternativa correta
Es posible usar type para identificar valores numéricos dentro de un dato textual. Por ejemplo, al recibir una base de datos que contiene fechas de compra de una empresa, siendo "fecha_compra" una variable de tipo string, es posible encontrar el día, mes y año con type, como se muestra a continuación.

fecha_compra = '10/07/2023'
type(fecha_compra)
************************************************************************************************+
08 Variables de texto
//Resumen: id(texto)=> dirección de memoria, texto (acá es igual a print(texto)
Métodos:  id(v),type(v),print(v), v.strip(),v.upper(), v.lower(), v.replace('y', 't')

En esta clase, se abordó el tema de las cadenas de texto, o strings, en Python. Se explicó cómo crear strings asignando un texto a una variable utilizando comillas simples o dobles. Se presentó el concepto de que las strings son objetos que tienen métodos que permiten manipular su contenido.

Se discutieron varios métodos útiles, como .upper() para convertir el texto a mayúsculas, .lower() para convertirlo a minúsculas, .strip() para eliminar espacios en blanco al inicio y al final, y .replace() para sustituir partes del texto. Se enfatizó la importancia de almacenar las transformaciones en una nueva variable, ya que las operaciones no modifican el objeto original, sino que crean uno nuevo en un espacio de memoria diferente.

Finalmente, se mencionó la relevancia de entender cómo Python maneja la memoria y las variables, lo cual es crucial para evitar errores en la manipulación de datos. Se anticipó que en la próxima clase se abordará cómo capturar datos ingresados por el usuario.
*******************************************************************************
09
Para saber más: otros operadores
 Siguiente pregunta

Durante las clases, aprendimos a sumar, restar, multiplicar y dividir variables numéricas en Python. Pero también existen otros cálculos matemáticos que se pueden realizar mediante operadores aritméticos, como la exponenciación, el módulo y la división entera.

Exponenciación (**)

Podemos elevar un número a una potencia específica utilizando el operador **. Para obtener este resultado, definimos un valor a la izquierda del operador y la potencia deseada del número a la derecha. Por ejemplo, sabemos que 2 elevado a la 3 es igual a 8 (2 * 2 * 2 = 8). Para realizar este cálculo, escribimos:

2**3
Copia el código
Salida: 8

El mismo ejemplo se puede hacer con variables:

operador = 2
potencia = 3
operador ** potencia
Copia el código
Salida: 8

Módulo (%)

El operador de módulo % puede devolver el residuo de una división entera entre dos números. Recuerda que el residuo de una división es el número que queda cuando la división no es exacta.

Para calcular el módulo de una división, colocamos el dividendo a la izquierda del operador % y el divisor a la derecha. Por ejemplo, para encontrar el residuo de la división de 7 entre 3, podemos ejecutar los siguientes códigos:

7%3
Copia el código
Salida: 1

O con variables:

dividendo = 7
divisor = 3
dividendo % divisor
Copia el código
Salida: 1

División entera (//)

Esta operación devuelve el resultado de la división entera entre dos números, es decir, solo devuelve la parte entera de una división. Por ejemplo, sabemos que la división exacta de 7 por 3 (7/3) resulta en el valor 2.333333.... Si esta fuera una división entera, el resultado sería simplemente 2. La sintaxis consiste en colocar el valor del numerador, el operador // y luego el denominador, como se muestra a continuación:

7 // 3
Copia el código
Salida: 2

El mismo ejemplo se puede hacer con variables:

numerador = 7
denominador = 3
numerador // denominador
Copia el código
Salida: 2

Puedes probar todos los ejemplos en tu cuaderno, verificar sus resultados y realizar pruebas modificando los valores.
************************************************************************************
10
Colectando datos
https://docs.python.org/es/3.13/library/index.html
funciones Ej input()
función input, que nos permite recoger información directamente del usuario. Se explicó que cualquier dato ingresado mediante input se almacena como un string, independientemente de si se trata de un número entero o decimal.

Se destacó la importancia de convertir estos strings a tipos numéricos, como enteros (int) o flotantes (float), para poder realizar operaciones matemáticas adecuadas. Se mostró cómo utilizar la función format para presentar los resultados de manera más legible, incluyendo el uso de nuevas líneas y tabulaciones para mejorar la estética de la salida.

Finalmente, se mencionó que esta clase fue una introducción a la manipulación de datos en Python y que en la próxima clase se abordarán las estructuras condicionales, que son fundamentales en la programación.
*********************************************
11
Para saber más: tabla unicode
 Siguiente pregunta

Python es un lenguaje de programación caracterizado por el uso del estándar Unicode de caracteres. Este estándar permite que desarrolladores de todo el mundo trabajen con textos y caracteres en diferentes idiomas de manera muy sencilla, sin preocuparse por problemas de compatibilidad.

Esto fue posible gracias al desarrollo de la tabla Unicode, una tabla de codificación de caracteres que asocia códigos numéricos con caracteres específicos. Su objetivo era incluir caracteres de todos los idiomas y sistemas de escritura existentes en el mundo. Hasta la versión 15.0, el estándar ya agrupa más de 140,000 caracteres, que incluyen letras, números, símbolos y emojis. Puedes ver las estadísticas de cada versión y la cantidad de caracteres por versión en este enlace.

Además, Unicode surgió como una alternativa a otras tablas de caracteres, como ASCII, que solo admite caracteres del alfabeto inglés y algunos símbolos. Por lo tanto, es muy importante ya que permite la representación de caracteres de diferentes idiomas (como la "ç" en portugués, la "ñ" en español o la "П" en ruso) y scripts de manera consistente e independiente del dispositivo o plataforma, lo que es fundamental para la globalización y la representación precisa de textos en diferentes idiomas.

Es importante recordar que la tabla Unicode se actualiza y se expande constantemente, incluyendo nuevos caracteres y scripts. Esto asegura que siga siendo relevante y útil para admitir la representación de todos los idiomas y sistemas de escritura del mundo. Puedes seguir las actualizaciones en el sitio unicode.org y acceder a las codificaciones de cada carácter de este estándar en la Wikipedia o en documentos oficiales en PDF.

Podemos imprimir un elemento de la tabla Unicode en nuestro cuaderno utilizando la función chr, que devuelve una cadena con el carácter especificado. Su sintaxis es la siguiente: chr(número_del_carácter). Por ejemplo, vamos a imprimir el carácter "@" con chr(). Según la tabla, sabemos que "@" corresponde al número 64, así que lo reprodujimos:

chr(64)
Copia el código
Salida: '@'

Se pueden probar y observar varias combinaciones de números en las salidas. Siéntete libre de probar varias combinaciones e incluso crear frases.

También es posible concatenar cadenas con el operador "+". Sabiendo esto, si unimos varios caracteres, podemos formar una palabra. Por ejemplo, vamos a construir la palabra "Hola" ('H' + 'o' + 'l' + 'a'):

chr(72) + chr(111) +  chr(108) + chr(97)
Copia el código
Salida: 'Hola'

https://www.unicode.org/versions/stats/
******************************************************************************
12
Para saber más: diversos formatos de print()
 Siguiente pregunta

Podemos visualizar el resultado de variables dentro de cadenas de texto, así como imprimir el texto final con un print. Durante la lección, aprendimos a utilizar la f-string (formateo de cadena), en la que colocamos una f antes de crear la cadena y las variables se colocan entre llaves {}. Ejemplo:

nombre = "Ana María"
edad = 17
print(f"El nombre de la alumna es {nombre} y su edad es {edad} años.")
Copia el código
Salida: 'El nombre de la alumna es Ana María y su edad es 17 años.'

Pero existen otros métodos de formateo, como el uso del operador de formateo de cadena o la función .format().

Operador de Formateo:

Este operador de formateo permite la inserción de variables en puntos específicos en la cadena de texto utilizando el operador %. Este operador funciona como un marcador, indicando dónde se expondrá el valor de la variable en la cadena.

El % debe ir acompañado de una palabra clave para cada tipo de variable que se desee agregar. De acuerdo con la tabla siguiente:

Tipo de Variable	Palabra Clave
Cadena de texto	%s
Entero	%d
Punto flotante	%f
Caractér	%c
De esta manera, para insertar una variable, puedes agregar el operador en la cadena en el punto deseado. Luego del final de la cadena, agrega nuevamente el %, especificando la variable entre paréntesis. Podemos ver esta estructura en el ejemplo siguiente:

nombre_alumno = 'Penélope Camacho'
print('Nombre del alumno: %s' %(nombre_alumno))
Copia el código
Salida: 'Nombre del alumno: Penélope Camacho'

Si tienes más de una variable, debes ordenarlas según su aparición en el texto y separarlas por comas. Por ejemplo:

nombre_alumno = 'Penélope Camacho'
edad_alumno = 11
media_alumno = 9.95
print('Nombre del alumno es %s, tiene %d años y su media es %f.' %(nombre_alumno, edad_alumno, media_alumno))
Copia el código
Salida: 'Nombre del alumno es Penélope Camacho, tiene 11 años y su media es 9.950000.'

Cuando trabajamos con números de coma flotante (float), podemos determinar la cantidad de decimales después del punto utilizando la sintaxis %.xf, donde x es el número de decimales deseados. Utilizando las mismas variables del ejemplo anterior, el código con %.xf se vería así:

print('Nombre del alumno es %s, tiene %d años y su media es %.2f.' %(nombre_alumno, edad_alumno, media_alumno))
Copia el código
Salida: 'Nombre del alumno es Penélope Camacho, tiene 11 años y su media es 9.95.'

Un detalle importante es que los operadores de formateo de cadena con % no funcionan directamente con valores booleanos. Una forma de manejarlo es convirtiendo el valor booleano en una cadena antes de utilizarlo en el formateo con la función str(). Por ejemplo:

x = True
print("Valor de x: %s" % str(x))
Copia el código
Esto no es un problema con las f-strings o .format.

Método .format():

También es posible utilizar el método .format() para formatear cadenas. Es más flexible y permite pasar las variables directamente dentro de la cadena, sin necesidad de operadores %. Los marcadores son simplemente {}. Por ejemplo:

nombre_alumno = 'Penélope Camacho'
print('Nombre del alumno: {}'.format(nombre_alumno))
Copia el código
Del mismo modo que se hace con el operador, puedes usarlo con varias variables:

nombre_alumno = 'Fabricio Daniel'
edad_alumno = 15
media_alumno = 9.95
print('Nombre del alumno es {}, tiene {} años y su media es {}.' .format(nombre_alumno, edad_alumno, media_alumno))
Copia el código
Nota que con .format(), no tienes el problema de los decimales de coma flotante. Tampoco tienes este problema con las f-strings.

En resumen, cada uno de estos métodos tiene sus ventajas y desventajas. Se recomienda utilizar f-strings, ya que son más legibles y fáciles de usar. Sin embargo, cada desarrollador puede elegir el método que le parezca más apropiado.

Caracteres Especiales:

Además de la formateo de inserción de variables en una cadena, también existen caracteres especiales. Se utilizan para representar acciones especiales o caracteres que no se pueden escribir directamente, como el “Enter” y la tabulación. A continuación, presentamos algunos de ellos. Intenta replicar todos los ejemplos y observa el resultado final.

\n es el carácter de nueva línea y se usa para saltar una línea en el texto (similar a la función "Enter"). Ejemplo:

print("Estudiar es un esfuerzo constante,\nEs como cultivar una planta,\nNecesitamos dedicación y paciencia,\nPara ver madurar el fruto.")
Copia el código
\t es el carácter de tabulación y se utiliza para agregar un espacio de tabulación en el texto. Ejemplo:

print('Cantidad\tCalidad\n5 muestras\tAlta\n3 muestras\tBaja')
Copia el código
\\ se usa para imprimir una sola barra invertida. Si no se utiliza una doble barra invertida, el código podría generar un error o un resultado inesperado, ya que Python considera \ como un carácter especial. Usamos esta sintaxis para garantizar que no ocurran errores. Ejemplo:

print("Ruta del archivo: C:\\archivos\\documento.csv")
Copia el código
\" se utiliza para imprimir comillas dobles cuando estamos trabajando con una cadena creada con comillas dobles " en el interior. Sin embargo, esto no es necesario si la cadena se crea con comillas simples '. Ejemplo:

print("Una vez oí: \"Los frutos del conocimiento son los más dulces y duraderos de todos.\"")
Copia el código
\' se utiliza para imprimir comillas simples cuando estamos trabajando con una cadena creada con comillas simples '. Si la cadena se crea con comillas dobles ", esto no es necesario. Ejemplo:

print('Mi profesora una vez dijo: \'Estudiar es la clave del éxito.\'')
*****************************************************************************************
13
¿Qué hace la función input()?
 Siguiente pregunta

Aprendemos otra función de Python llamada input(). Selecciona la alternativa que describe lo que hace esta función y proporciona un ejemplo con su sintaxis.

Alternativa correta
La función input simplemente imprime un contenido especificado por el programador. Un ejemplo de uso de esta función es el siguiente código:

input('¿Cuál es tu nombre? ')

Alternativa correta
La función input se utiliza para leer las entradas del usuario en formato de cadena (string) y devolver el valor leído. Un ejemplo de uso de esta función es el siguiente código:

nombre = input('¿Cuál es tu nombre? ')

La función input permite que el usuario introduzca datos en el programa. Su sintaxis es sencilla, ya que escribimos "input" seguido de paréntesis (). Dentro de ellos, podemos colocar texto que aparecerá antes de la lectura. Al ejecutar el código de la alternativa, el programa imprimirá el mensaje "¿Cuál es tu nombre?" y esperará la entrada del usuario. Cuando el usuario escriba su nombre y presione la tecla Enter, el programa almacenará la entrada en una variable llamada "nombre".

Alternativa correta
La función input se utiliza para leer solo entradas numéricas y también devolver valores numéricos. Un ejemplo de uso de esta función es el siguiente código:

edad = input('¿Cuál es tu edad? ')

La sintaxis es correcta. Sin embargo, la función input no se limita a un solo tipo de entrada.
********************************************************************
14
Desafío: ¡Es hora de practicar!
 Siguiente pregunta

Vamos a practicar el uso de varios tipos de variables y la función input a través de algunas actividades. Resuelve los problemas propuestos en código.

Recopilación y muestra de datos

1 - Crea un programa que solic-ite al usuario que escriba su nombre y luego imprima "Hola, [nombre]."

2 - Crea un programa que solicite al usuario que escriba su nombre y edad, y luego imprima "Hola, [nombre], tienes [edad] años."

3 - Crea un programa que solicite al usuario que escriba su nombre, edad y altura en metros, y luego imprima "Hola, [nombre], tienes [edad] años y mides [altura] metros."

Calculadora con operadores

4 - Crea un programa que solicite dos valores numéricos al usuario y luego imprima la suma de ambos valores.

5 - Crea un programa que solicite tres valores numéricos al usuario y luego imprima la suma de los tres valores.

6 - Crea un programa que solicite dos valores numéricos al usuario y luego imprima la resta del primero menos el segundo valor.

7 - Crea un programa que solicite dos valores numéricos al usuario y luego imprima la multiplicación de los dos valores.

8 - Crea un programa que solicite dos valores numéricos, un numerador y un denominador, y realice la división entre los dos valores. Asegúrate de que el valor del denominador no sea igual a 0.

9 - Crea un programa que solicite dos valores numéricos, un operador y una potencia, y realice la exponenciación entre estos dos valores.

10 - Crea un programa que solicite dos valores numéricos, un numerador y un denominador, y realice la división entera entre los dos valores. Asegúrate de que el valor del denominador no sea igual a 0.

11 - Crea un programa que solicite dos valores numéricos, un numerador y un denominador, y devuelva el resto de la división entre los dos valores. Asegúrate de que el valor del denominador no sea igual a 0.

12 - Crea un código que solicite las 3 notas de un estudiante e imprima el promedio de las notas.

13 - Crea un código que calcule e imprima el promedio ponderado de los números 5, 12, 20 y 15 con pesos respectivamente iguales a 1, 2, 3 y 4.

Editando textos

14 - Crea una variable llamada "frase" y asígnale una cadena de texto de tu elección. Luego, imprime la frase en pantalla.

15 - Crea un código que solicite una frase y luego imprima la frase en pantalla.

16 - Crea un código que solicite una frase al usuario y luego imprima la misma frase ingresada pero en mayúsculas.

17 - Crea un código que solicite una frase al usuario y luego imprima la misma frase ingresada pero en minúsculas.

18 - Crea una variable llamada "frase" y asígnale una cadena de texto de tu elección. Luego, imprime la frase sin espacios en blanco al principio y al final.

	

20 - Crea un código que solicite una frase al usuario y luego imprima la misma frase sin espacios en blanco al principio y al final, además de convertirla a minúsculas.

21 - Crea un código que solicite una frase al usuario y luego imprima la misma frase con todas las vocales "e" reemplazadas por la letra "f".

22 - Crea un código que solicite una frase al usuario y luego imprima la misma frase con todas las vocales "a" reemplazadas por el carácter "@".

23 - Crea un código que solicite una frase al usuario y luego imprima la misma frase con todas las consonantes "s" reemplazadas por el carácter "$".

Si necesitas ayuda, las opciones de solución a las actividades estarán disponibles en la sección "Opinión del instructor".

 Discutir en el Foro

Opinión del instructor

Pueden existir diversas formas de resolver una cuestión. A continuación, presentaré cómo resolví los problemas, lo que no significa que sean las mejores soluciones, pero son una opción de solución.

Recopilación y muestreo de datos

1 - Podemos solicitar el nombre con la función input y asignar el resultado de la salida a una variable. A continuación, podemos imprimir el resultado de la variable en la función print usando la formatación f-string.

nombre = input('Ingrese su nombre: ')
print(f'¡Hola, {nombre}!')
Copia el código
2 - Podemos solicitar el nombre y la edad con la función input y asignar el resultado de la salida a una variable. En el caso de la edad, es necesaria una conversión de la salida de input a un valor entero con la función int(). A continuación, podemos imprimir el resultado de las recopilaciones en la función print usando la formateación f-string.

nombre = input('Ingrese su nombre: ')
edad = int(input('Ingrese su edad: '))
print(f'¡Hola, {nombre}, tienes {edad} años!')
Copia el código
3 - Podemos solicitar el nombre, la edad y la altura con la función input y asignar el resultado de la salida a una variable. En el caso de la edad, es necesaria una conversión de la salida de input a un valor entero con la función int(). Para la altura, es necesario realizar una conversión al tipo de valor flotante con la función float(). A continuación, podemos imprimir el resultado de las recopilaciones en la función print usando la formateación f-string.

nombre = input('Ingrese su nombre: ')
edad = int(input('Ingrese su edad: '))
altura = float(input('Ingrese su altura: '))
print(f'¡Hola, {nombre}, tienes {edad} años y mides {altura} metros!')
Copia el código
Calculadora con operadores

4 - Podemos recopilar los dos valores con input y convertir la salida a un número entero con la función int(). Luego, podemos mostrar el resultado de la suma entre las dos entradas con +.

a = int(input('Ingrese el primer valor: '))
b = int(input('Ingrese el segundo valor: '))
print(a + b)
Copia el código
5 - Usando la misma lógica que en la pregunta anterior, podemos recopilar los tres valores con input y convertir la salida a números enteros con la función int(). Luego, podemos mostrar el resultado de la suma de los tres valores con +.

a = int(input('Ingrese el primer valor: '))
b = int(input('Ingrese el segundo valor: '))
c = int(input('Ingrese el tercer valor: '))
print(a + b + c)
Copia el código
6 - Podemos recopilar los dos valores con input y convertir la salida a números enteros con la función int(). Luego, podemos mostrar el resultado de la resta del primer valor menos el segundo valor con -.

a = int(input('Ingrese el primer valor: '))
b = int(input('Ingrese el segundo valor: '))
print(a - b)
Copia el código
7 - Podemos recopilar los dos valores con input y convertir la salida a números enteros con la función int(). Luego, podemos mostrar el resultado de la multiplicación de los dos valores con *.

a = int(input('Ingrese el primer valor: '))
b = int(input('Ingrese el segundo valor: '))
print(a * b)
Copia el código
8 - Podemos recopilar el numerador y denominador con input y convertir la salida a números enteros con la función int(). Luego, podemos mostrar el resultado de la división entre los dos valores con /.

numerador = int(input('Ingrese el numerador: '))
denominador = int(input('Ingrese el denominador (OBS: el valor no puede ser nulo): '))
print(numerador / denominador)
Copia el código
9 - Podemos recopilar el operador y potencia con input y convertir la salida a números enteros con la función int(). Luego, podemos mostrar el resultado de la exponenciación entre estos dos valores con **.

operador = int(input('Ingrese el valor del operador: '))
potencia = int(input('Ingrese el valor de la potencia: '))
print(operador ** potencia)
Copia el código
10 - Podemos recopilar el numerador y denominador con input y convertir la salida a números enteros con la función int(). Luego, podemos mostrar el resultado de la división entera entre los dos valores con //.

numerador = int(input('Ingrese el numerador: '))
denominador = int(input('Ingrese el denominador (OBS: el valor no puede ser nulo): '))
print(numerador // denominador)
Copia el código
11 - Podemos recopilar el numerador y denominador con input y convertir la salida a números enteros con la función int(). Luego, podemos mostrar el resultado del resto de la división entre los dos valores con %.

numerador = int(input('Ingrese el numerador: '))
denominador = int(input('Ingrese el denominador (OBS: el valor no puede ser nulo): '))
print(numerador % denominador)
Copia el código
12 - Podemos recopilar las tres notas con input y convertir la salida a números con decimales utilizando la función float(). Luego, podemos mostrar el resultado del promedio entre las tres variables sumando las notas con + y dividiendo la suma entre 3.

nota_1 = float(input('Ingrese la 1° nota: '))
nota_2 = float(input('Ingrese la 2° nota: '))
nota_3 = float(input('Ingrese la 3° nota: '))
print(f'Media {(nota_1+nota_2+nota_3)/3}.')
Copia el código
13 - Calculamos la media ponderada multiplicando los pesos por sus respectivos valores y sumando el resultado de cada multiplicación. El valor de estas sumas se divide entre la suma total de los pesos. Con el comando print, imprimimos el resultado del cálculo de la media.

media_ponderada = (5*1 + 12*2 + 20*3 + 15*4) / (1+2+3+4)
print(f'Media {media_ponderada}.')
Copia el código
Editando textos

14 - Definimos una frase arbitraria entre comillas simples y la imprimimos insertando la variable en un comando print.

frase = '¡Hola Python!'
print(frase)
Copia el código
15 - Recopilamos una frase utilizando la función input y luego imprimimos el resultado con el comando print.

frase = input('Escribe una frase: ')
print(frase)
Copia el código
16 - Recopilamos una frase utilizando la función input y luego mostramos su valor en mayúsculas utilizando el método upper. Podemos mostrar la salida de esto en un comando print.

frase = input('Escribe una frase: ')
print(frase.upper())
Copia el código
17 - Recopilamos una frase utilizando la función input y luego mostramos su valor en minúsculas utilizando el método lower. Podemos mostrar la salida de esto en un comando print.

frase = input('Escribe una frase: ')
print(frase.lower())
Copia el código
18 - Para este ejemplo, es interesante definir una frase con espacios al principio y al final de la frase. Una vez hecho esto, podemos eliminar estos espacios utilizando el método strip y mostrar el resultado en un comando print.

frase = ' ¡Hola Python! '
print(frase.strip())
Copia el código
19 - Recopilamos una frase utilizando la función input, incluso si no estamos seguros de si tendrá espacios al principio y al final de la frase. Luego, podemos eliminar estos espacios utilizando el método strip. El resultado se puede mostrar en un comando print.

frase = input('Escribe una frase: ')
print(frase.strip())
Copia el código
20 - Recopilamos una frase utilizando la función input, incluso si no estamos seguros de si tendrá espacios al principio y al final de la frase. Luego, eliminamos estos espacios utilizando el método strip y también usamos el método lower junto con strip. El resultado se puede mostrar en un comando print.

frase = input('Escribe una frase: ')
print(frase.strip().lower())
Copia el código
21 - Recopilamos una frase utilizando la función input. Para asegurarnos de que los caracteres no estén en mayúsculas, convertimos toda la frase a minúsculas utilizando el método lower y luego aplicamos el método replace, definiendo el valor a reemplazar como 'e' y el nuevo valor como 'f'. El resultado se muestra en un comando print.

frase = input('Escribe una frase: ')
print(frase.lower().replace('e','f'))
Copia el código
22 - Recopilamos una frase utilizando la función input. Para asegurarnos de que los caracteres no estén en mayúsculas, convertimos toda la frase a minúsculas utilizando el método lower y luego aplicamos el método replace, definiendo el valor a reemplazar como 'a' y el nuevo valor como el carácter 64 según la tabla Unicode, que corresponde al carácter @. El resultado se muestra en un comando print.

frase = input('Escribe una frase: ')
print(frase.lower().replace('a',chr(64)))
Copia el código
23 - Recopilamos una frase utilizando la función input. Para asegurarnos de que los caracteres no estén en mayúsculas, convertimos toda la frase a minúsculas utilizando el método lower y luego aplicamos el método replace, definiendo el valor a reemplazar como 's' y el nuevo valor como el carácter 36 según la tabla Unicode, que corresponde al símbolo $. El resultado se muestra en un comando print.

frase = input('Escribe una frase: ')
print(frase.lower().replace('s',chr(36)))
Copia el código
Ejercitarse es importante para consolidar el contenido, desarrollar habilidades de codificación, identificar puntos que aún no se han comprendido, prepararse para desafíos futuros, desarrollar el pensamiento lógico y la resolución de problemas.

Teniendo esto en cuenta, es interesante realizar muchos ejercicios cuando se está aprendiendo un nuevo lenguaje de programación. Por lo tanto, busca completar los ejercicios propuestos y observa cómo te ayudan a progresar en tus habilidades de codificación.

Si tienes alguna pregunta, puedes comunicarte en el foro.
///////////////////////////////////////////////////////////////////////////////////////////////
15
Lo que aprendimos
 Siguiente pregunta

Lo que aprendimos en esta aula:

Crear variables en Python.
Distinguir entre los diferentes tipos de datos.
Realizar operaciones con variables numéricas.
Manipular variables de texto (cadenas de caracteres).
Recolectar datos de un usuario utilizando la función input().
*********************************************************************************************
03. Estructuras Condicionales
01 Proyecto del aula anterior = archivo.zip o clonar desde GitHub
02
Qué son las estructuras condicionales
Claro! En esta lección, aprendimos sobre las estructuras condicionales en Python, que son herramientas que nos permiten tomar decisiones en nuestro código. Se nos presentó un escenario en el que necesitamos determinar si los estudiantes están aprobando o reprobando sus asignaturas, basándonos en sus notas.

La nota de aprobación se establece entre 7 y 10, mientras que la nota de reprobación es cualquier valor menor a 7. Para comentar en el código, se puede usar el signo de numeral (#) para comentarios de una línea, y tres comillas (""") para comentarios de varias líneas.

La estructura condicional que se propone es: si la nota es mayor o igual a 7, el estudiante aprueba; de lo contrario, el estudiante reprueba. Esta lógica se implementará en Python, que tiene su propia sintaxis para manejar estas condiciones.

Si tienes alguna pregunta específica sobre el contenido, ¡no dudes en preguntar!
- - - - - - - - - - - -- -
03
Conociendo If y Else
condicionales en Python, específicamente las palabras clave if y else. Se explicó que una estructura condicional permite controlar el flujo de un programa, ejecutando diferentes bloques de código dependiendo de si una condición es verdadera o falsa.

Se destacó la sintaxis básica de if, que consiste en la palabra clave seguida de una condición y dos puntos. Si la condición es verdadera, se ejecuta el bloque de código indentado. Por otro lado, si la condición es falsa, se puede utilizar else para ejecutar un bloque de código alternativo.

Se enfatizó la importancia de la indentación en Python, que determina qué código pertenece a cada bloque. Además, se mostró un ejemplo práctico donde se verificaba si un número era menor o mayor que otro, y cómo se imprimían diferentes mensajes dependiendo del resultado de la condición.

Finalmente, se mencionó que el else se utiliza para manejar el caso en que la condición del if no se cumple, permitiendo así una mayor flexibilidad en la lógica del programa.
*******************************************************************************
04
¿Dónde aplicar los condicionales?
 Siguiente pregunta

La declaración condicional "if" es una estructura que permite la ejecución de un bloque de código solo si cierta condición es verdadera, y se puede utilizar en diversas aplicaciones en la ciencia de datos, como la filtración de datos basada en una condición.

Por lo tanto, marca la alternativa que contenga una aplicación en Ciencia de Datos en la que tenga sentido utilizar una declaración condicional.

Alternativa correta
Una declaración condicional puede realizar la transformación de datos. Por ejemplo, al recibir un número de identificación fiscal como una variable de texto, es posible utilizar una declaración condicional para realizar la transformación en un valor numérico.


Alternativa correta
Una estructura condicional se puede utilizar para análisis que involucran estadísticas descriptivas, como el cálculo de la media, la desviación estándar o la mediana.


Alternativa correta
Con una declaración condicional, podemos verificar si un conjunto de datos contiene valores faltantes o nulos que pueden afectar negativamente el análisis.


Una expresión condicional puede verificar si los datos son nulos o faltantes, lo que permite el tratamiento de los mismos. Este tipo de valores es común en un conjunto de datos. La identificación de datos faltantes o nulos permitirá, por ejemplo, reemplazar o eliminar estos valores para evitar errores o resultados incorrectos en el análisis.
**********************************************************************
05
Para saber más: operadores relacionales
 Siguiente pregunta

Una condición no es más que una comparación entre datos a partir de la cual podemos obtener el resultado verdadero o falso de una condición. La comparación puede realizarse mediante operadores relacionales cuya misión es comparar valores y determinar si una expresión es verdadera o falsa. A continuación, conoceremos los operadores lógicos y cómo utilizarlos.

Mayor que (>)

Devuelve verdadero si el valor a la izquierda del símbolo es mayor que el de la derecha. Su sintaxis, valor_1 > valor_2, representa una comparación que solo será verdadera si valor_1 es mayor que valor_2. Con este operador relacional, podemos verificar si una persona es mayor que otra al comparar sus edades, como se muestra en el siguiente ejemplo:

edad_maria = int(input('Ingrese la edad de María: '))
edad_beatriz = int(input('Ingrese la edad de Beatriz: '))

if edad_maria > edad_beatriz:
  print('María es mayor que Beatriz.')
Copia el código
El operador mayor que (>) devuelve un valor falso si los valores comparados son iguales o si el valor a la izquierda del símbolo es inferior al de la derecha.

Menor que (<)

Devuelve verdadero si el valor a la izquierda del símbolo es menor que el de la derecha. Su sintaxis es valor_1 < valor_2. Esta comparación solo será verdadera si valor_1 es menor que valor_2. Con este operador relacional, también podemos verificar si una persona es menor que otra al comparar sus edades, como se muestra a continuación:

edad_maria = int(input('Ingrese la edad de María: '))
edad_beatriz = int(input('Ingrese la edad de Beatriz: '))

if edad_maria < edad_beatriz:
  print('María es menor que Beatriz.')
Copia el código
Este operador también devuelve un valor falso si los valores comparados son iguales o si el valor a la izquierda del símbolo es superior al de la derecha.

Mayor o igual a (>=)

Devuelve verdadero si el valor a la izquierda del símbolo es mayor o igual al valor a la derecha. Su sintaxis es valor_1 >= valor_2. Esta comparación solo será verdadera si valor_1 es mayor o igual a valor_2. Con este operador relacional, podemos verificar, por ejemplo, si una empresa tiene una cantidad mayor o igual a la de otra, como se muestra a continuación:

empleados_empresa_1 = int(input('Ingrese la cantidad de empleados de la empresa 1: '))
empleados_empresa_2 = int(input('Ingrese la cantidad de empleados de la empresa 2: '))

if empleados_empresa_1 >= empleados_empresa_2:
  print('La empresa 1 tiene una cantidad de empleados mayor o igual a la empresa 2.')
Copia el código
Menor o igual a (<=)

Devuelve verdadero si el valor a la izquierda del símbolo es menor o igual al valor de la derecha. Su sintaxis es valor_1 <= valor_2. Esta comparación solo será verdadera si valor_1 es menor o igual a valor_2. Con este operador relacional, podemos verificar si una empresa tiene una cantidad menor o igual a otra, como se muestra a continuación:

empleados_empresa_1 = int(input('Ingrese la cantidad de empleados de la empresa 1: '))
empleados_empresa_2 = int(input('Ingrese la cantidad de empleados de la empresa 2: '))

if empleados_empresa_1 <= empleados_empresa_2:
  print('La empresa 1 tiene una cantidad de empleados menor o igual a la empresa 2.')
Copia el código
Igual a (==)

Devuelve verdadero si el valor a la izquierda del símbolo es igual al valor de la derecha. Su sintaxis, valor_1 == valor_2, representa una comparación que solo será verdadera si valor_1 es igual a valor_2. Con este operador relacional, podemos verificar si dos libros tienen el mismo título mediante una comparación de cadenas, como se muestra en el siguiente ejemplo:

libro_1 = input('Ingrese el título del 1° libro: ')
libro_2 = input('Ingrese el título del 2° libro: ')

if libro_1 == libro_2:
  print('Los libros tienen el mismo título.')
Copia el código
También es posible realizar esta comparación con valores numéricos.

Diferente de (!=)

Devuelve verdadero si el valor a la izquierda del símbolo es diferente del valor a la derecha. Su sintaxis, valor_1 != valor_2, representa una comparación que solo será verdadera si valor_1 es diferente de valor_2. Este operador es el inverso de ==. Con él, podemos verificar si dos libros tienen títulos diferentes mediante una comparación de cadenas, como se muestra a continuación:

libro_1 = input('Ingrese el título del 1° libro: ')
libro_2 = input('Ingrese el título del 2° libro: ')

if libro_1 != libro_2:
  print('Los libros tienen títulos diferentes.')
Copia el código
También es posible realizar esta comparación con valores numéricos.
******************************************************************************************
06
Utilizando If y Else
En esta clase, aprendimos sobre las estructuras condicionales en Python, específicamente utilizando las instrucciones if y else. El objetivo fue crear un algoritmo que evalúe las calificaciones de los estudiantes y determine si aprobaron o reprobaron.

Se estableció que un estudiante aprueba si su calificación es igual o superior a 7. Si la calificación está entre 5 y 7, el estudiante tiene la oportunidad de asistir a un curso de recuperación. En caso de que la calificación sea menor a 5, el estudiante reprueba.

Se mostró cómo estructurar estas condiciones utilizando múltiples if para manejar diferentes rangos de calificaciones. Sin embargo, se destacó la importancia de ser específicos con las condiciones, ya que un else mal colocado puede afectar la lógica del programa. Se explicó que si un if es falso, el flujo de control puede saltar a un else que no considera todas las condiciones anteriores, lo que puede llevar a errores en la evaluación.

En resumen, la clase enfatizó la importancia de la lógica condicional en la programación y cómo estructurar correctamente las condiciones para obtener resultados precisos.

¿Cómo puedo analizar si apliqué correctamente los conceptos de la clase?

Para analizar si aplicaste correctamente los conceptos de la clase, puedes seguir estos pasos:

Revisar tu código: Asegúrate de que tu código esté estructurado correctamente. Verifica que estés utilizando las instrucciones if, elif y else de manera adecuada para evaluar las condiciones de las calificaciones.

Probar diferentes entradas: Ejecuta tu código con diferentes valores de calificación (por ejemplo, 4, 5, 6, 7, 8) y observa si los resultados son los esperados:

Calificaciones menores a 5 deben resultar en "reprobó".
Calificaciones entre 5 y 7 deben indicar que el estudiante puede ir a recuperación.
Calificaciones de 7 o más deben resultar en "aprobó".
Analizar los mensajes: Asegúrate de que los mensajes que se imprimen sean claros y reflejen correctamente el resultado de la evaluación.

Verificar la lógica: Revisa la lógica de tus condiciones. Pregúntate si hay alguna situación que no hayas considerado. Por ejemplo, ¿qué sucede si la calificación es exactamente 7? ¿Tu código lo maneja correctamente?

Pedir retroalimentación: Si es posible, comparte tu código con un compañero o un tutor y pídeles que lo revisen. A veces, una segunda opinión puede ayudarte a identificar errores que pasaste por alto.

Reflexionar sobre el flujo de control: Piensa en cómo se mueve el flujo de tu programa. ¿Está claro qué condiciones llevan a cada resultado? Asegúrate de que no haya confusiones en la lógica.

Si sigues estos pasos y encuentras que tu código funciona como se espera en todas las situaciones, es probable que hayas aplicado correctamente los conceptos de la clase. ¡Sigue practicando!

Copiar texto de Luri al portapapeles
Limpiar conversación
**********************************************************************************************************+
07
¿Qué es la cláusula else?
 Siguiente pregunta

Aprendimos una estructura condicional llamada "else". Selecciona la opción que describe lo que hace "else" y proporciona un ejemplo de su estructura.

Alternativa correta
El "else" es una estructura condicional opcional vinculada al "if". Verifica si la condición especificada en la estructura del "if" es verdadera o no. Si es verdadera, se ejecuta el bloque de código dentro del "else"; si es falsa, se ejecuta el bloque de código del "if". La sintaxis de su estructura se puede ejemplificar mediante una declaración condicional simple. Para verificar si la primera calificación de un estudiante es mayor o igual que su segunda calificación en la misma materia, hacemos:

if nota_1 >= nota_2:
  print('La 2° nota es mayor que la 1°.')
else:
  print('La 2° nota es menor o igual a la 1°.')

Alternativa correta
El "else" es una estructura condicional vinculada al "if", y ambos no pueden construirse por separado. Por lo tanto, si se incluye un "if" en el código, debe existir un "else" vinculado a él. Esto es necesario porque se ejecuta cuando la condición especificada en la estructura del "if" anterior no es verdadera. La sintaxis de su estructura se puede ejemplificar mediante una declaración condicional simple. Para verificar si la primera calificación de un estudiante es menor o igual a su segunda calificación en la misma materia, hacemos:

if nota_1 <= nota_2:
  print('La 2° nota es mayor o igual a la 1°.')
else:
  print('La 2° nota es menor que la 1°.')

Alternativa correta
El "else" es una estructura condicional opcional vinculada al "if". Se ejecuta cuando la condición especificada en la estructura condicional anterior no es verdadera. La sintaxis de su estructura se puede ejemplificar mediante una declaración condicional simple. Para verificar si la primera calificación de un estudiante es mayor o igual que su segunda calificación en la misma materia, hacemos:

if nota_1 >= nota_2:
  print('La 2° nota es menor o igual a la 1°.')
else:
  print('La 2° nota es mayor que la 1°.')

Si la condición en el "if" (nota_1 >= nota_2) es falsa, el código dentro del bloque "if" se ignorará y el programa ejecutará el código dentro del bloque "else". Por lo tanto, se utiliza de manera que, si la condición no es verdadera, se tome una acción alternativa, lo que garantiza un control sobre todos los procesos del código.
*******************************************************************************+
08 Utilizando Elif
En esta clase, aprendimos sobre las estructuras condicionales en Python, enfocándonos en la cláusula elif. Esta cláusula se utiliza para manejar múltiples condiciones de manera más eficiente que usando solo if y else.

La sintaxis básica es: primero se utiliza un if para evaluar una condición. Si esta condición es falsa, se puede usar elif para evaluar otra condición. Si ninguna de las condiciones anteriores se cumple, se puede finalizar con un else para ejecutar un bloque de código alternativo.

El uso de elif permite encadenar varias condiciones, lo que facilita la lógica del programa y ahorra espacio en el código. Además, el intérprete de Python evalúa cada condición de forma individual hasta encontrar una que sea verdadera, o ejecuta el bloque de else si ninguna se cumple.

En resumen, elif es una herramienta poderosa para manejar múltiples condiciones en la lógica de programación.
*************************************************************************************
09
¿Qué es la cláusula elif?
 Siguiente pregunta

La cláusula elif es una estructura condicional muy útil. Selecciona la alternativa que mejor describe su funcionamiento y da un ejemplo.

Alternativa correta
El "elif" es una estructura condicional vinculada al "if" y al "else". Si es necesario agregar un "elif", será obligatorio colocar un "else" después de la declaración de la estructura. Podemos ejemplificar esto mediante una declaración condicional para clasificar los precios de una propiedad vendida en el mercado inmobiliario de la siguiente manera:

if valor_inmueble < 100000:
    print('Propiedad de entrada')
elif valor_inmueble >= 100000 and valor_inmueble < 500000:
    print('Propiedad de valor medio')
else:
    print('Propiedad de alto valor')

La sintaxis de uso permite colocar un "else" después del "elif". Sin embargo, no es necesario colocar obligatoriamente un "else" en el código para que exista una estructura "elif".

Alternativa correta
El "elif" se ejecuta cuando la condición especificada en la estructura del "if" anterior no es verdadera. En este caso, el código dentro del bloque "if" se ignorará y el programa ejecutará directamente el código dentro del bloque "elif". Podemos ejemplificar esto mediante una declaración condicional al clasificar los precios de una propiedad vendida en el mercado inmobiliario, como se muestra a continuación:

if valor_inmueble < 500000:
    print('Propiedad de valor medio')
elif:
    print('Propiedad de alto valor')

Alternativa correta
El "elif" es una estructura condicional opcional vinculada al "if". Permite verificar múltiples condiciones de manera encadenada, de modo que solo se ejecutará si la condición anterior no se cumple. Podemos ejemplificar esto mediante una declaración condicional para clasificar los precios de una propiedad vendida en el mercado inmobiliario, como se muestra en el código siguiente:

if valor_inmueble < 100000:
    print('Propiedad de entrada')
elif valor_inmueble >= 100000 and valor_inmueble < 500000:
    print('Propiedad de valor medio')
elif valor_inmueble >= 500000:
    print('Propiedad de alto valor')

El "elif" permite agregar múltiples condiciones a un código y se ejecuta solo si las condiciones del "if" o de todos los "elif" anteriores son falsas. Por lo tanto, el "elif" proporciona una manera de verificar varias condiciones diferentes sin necesidad de utilizar varias declaraciones "if". En el ejemplo, el "elif" se utiliza para verificar si el valor de la propiedad está entre 100,000 y 500,000 y también si el valor es igual o superior a 500,000, pero esta verificación solo se realiza si la condición anterior es falsa.
***************************************************************************************+
10 Operadores lógicos
En esta clase, aprendimos sobre las estructuras condicionales en Python, centrándonos en los operadores lógicos: AND, OR y NOT. Estos operadores nos permiten combinar diferentes condiciones para controlar el flujo de nuestro programa de manera más compleja.

AND: La salida es verdadera solo si ambas condiciones son verdaderas.
OR: La salida es verdadera si al menos una de las condiciones es verdadera.
NOT: Este operador invierte el valor de la condición; si es verdadero, se convierte en falso y viceversa.
Además, se introdujo la cláusula IN, que permite verificar si un elemento está presente en una colección, como una lista o una cadena de texto. Se mostró un ejemplo práctico donde se verificó si ciertos nombres de estudiantes estaban en una lista de aprobados.

Finalmente, se mencionó que en la próxima clase se abordarán las estructuras de repetición, que permiten ejecutar comandos múltiples veces.
****************************************************************************************+
11
Para saber más: tabla de la verdad
 Siguiente pregunta

Cuando deseamos crear una expresión lógica con operadores lógicos, es necesario comprender cómo funciona la tabla de verdad de cada uno de ellos para poder construir un código que produzca el resultado deseado. Estas tablas ayudan a comprender y analizar expresiones lógicas, como las que se encuentran en algoritmos de programación y a verificar la validez de una expresión lógica dada. La tabla de verdad ayuda a verificar los resultados para todas las posibles combinaciones de valores lógicos de una expresión lógica dada.

Vamos a conocer la tabla de verdad de los operadores lógicos and, or y not.

Operador and

La tabla de verdad del operador and muestra que la salida solo es Verdadero (True) si ambos operandos son Verdaderos. De lo contrario, devuelve Falso (False), como se muestra en la siguiente tabla:

operando_1	operando_2	operando_1 and operando_2
False		False		False
False		True		False
True		False		False
True		True		True
Operador or

La tabla de verdad del operador or muestra que la salida solo es Falso (False) si ambos operandos son Falsos; de lo contrario, devuelve Verdadero (True). Es decir, se devuelve True si al menos uno de los operandos es True, como se muestra a continuación:

operando_1	operando_2	operando_1 or operando_2
False		False		False
False		True		True
True		False		True
True		True		True
Operador not

El operador not tiene una tabla de verdad más simple, ya que simplemente invierte el valor del operando. Si el operando es Verdadero, devuelve Falso; si es Falso, devuelve Verdadero.

operando	not operando
True		False
False		True
****************************************************************************************************************
12
Desafio: ¡Es hora de practicar!
 Siguiente pregunta

Vamos practicar el uso de estructuras condicionales como el if, else y elif a través de algunas actividades. Ahora que estamos avanzando en los contenidos, podemos hacer los desafíos más interesantes: ¡trabajaremos en proyectos de código! Resuelve los problemas iniciales para prepararte para los proyectos:

Entrenando la programación

1 - Escribe un programa que pida a la persona usuaria que proporcione dos números y muestre el número más grande.

2 - Escribe un programa que solicite el porcentaje de crecimiento de producción de una empresa e informe si hubo un crecimiento (porcentaje positivo) o una disminución (porcentaje negativo).

3 - Escribe un programa que determine si una letra proporcionada por la persona usuaria es una vocal o una consonante.

4 - Escribe un programa que lea valores promedio de precios de un modelo de automóvil durante 3 años consecutivos y muestre el valor más alto y más bajo entre esos tres años.

5 - Escribe un programa que pregunte sobre el precio de tres productos e indique cuál es el producto más barato para comprar.

6 - Escribe un programa que lea tres números y los muestre en orden descendente.

7 -Escribe un programa que pregunte en qué turno estudia la persona usuaria ("mañana", "tarde" o "noche") y muestre el mensaje "¡Buenos Días!", "¡Buenas Tardes!", "¡Buenas Noches!" o "Valor Inválido!", según el caso.

8 - Escribe un programa que solicite un número entero a la persona usuaria y determine si es par o impar. Pista: Puedes usar el operador módulo (%).

9 - Escribe un programa que pida un número a la persona usuaria y le informe si es entero o decimal.

Momento de los proyectos

10 - Un programa debe ser escrito para leer dos números y luego preguntar a la persona usuaria qué operación desea realizar. El resultado de la operación debe incluir información sobre el número, si es par o impar, positivo o negativo, e entero o decimal.

11 - Escribe un programa que pida a la persona usuaria tres números que representan los lados de un triángulo. El programa debe informar si los valores pueden utilizarse para formar un triángulo y, en caso afirmativo, si es equilátero, isósceles o escaleno. Ten en cuenta algunas sugerencias:

Tres lados forman un triángulo cuando la suma de cualesquiera dos lados es mayor que el tercero;
Triángulo Equilátero: tres lados iguales;
Triángulo Isósceles: dos lados iguales;
Triángulo Escaleno: tres lados diferentes.
12 - Un establecimiento está vendiendo combustibles con descuentos variables. Para el etanol, si la cantidad comprada es de hasta 15 litros, el descuento será del 2% por litro. En caso contrario, será del 4% por litro. Para el diésel, si la cantidad comprada es de hasta 15 litros, el descuento será del 3% por litro. En caso contrario, será del 5% por litro. El precio por litro de diésel es de R$ 2,00 y el precio por litro de etanol es de R$ 1,70. Escribe un programa que lea la cantidad de litros vendidos y el tipo de combustible (E para etanol y D para diésel) y calcule el valor a pagar por el cliente. Ten en cuenta algunas sugerencias:

El valor del descuento será el producto del precio por litro, la cantidad de litros y el valor del descuento.
El valor a pagar por un cliente será el resultado de la multiplicación del precio por litro por la cantidad de litros menos el valor del descuento resultante del cálculo.
13 - En una empresa de venta de bienes raíces, debes crear un código que analice los datos de ventas anuales para ayudar a la dirección en la toma de decisiones. El código debe recopilar los datos de cantidad de ventas durante los años 2022 y 2023 y calcular la variación porcentual. A partir del valor de la variación, se deben proporcionar las siguientes sugerencias:

Para una variación superior al 20%: bonificación para el equipo de ventas.
Para una variación entre el 2% y el 20%: pequeña bonificación para el equipo de ventas.
Para una variación entre el 2% y el -10%: planificación de políticas de incentivo a las ventas.
Para bonificaciones inferiores al -10%: recorte de gastos.
Si necesitas ayuda, las opciones de solución para las actividades estarán disponibles en la sección "Opinión del instructor".
///////////////////////////////////////////////////////////////////////////////////////////////////////////
Opinión del instructor

Pueden existir diversas formas de resolver un problema. Presentaré cómo resolví estos problemas, lo cual no significa que sean las mejores soluciones, pero son una opción de solución.

1 -

# Recolectamos los números
num1 = float(input('Ingrese el primer número: '))
num2 = float(input('Ingrese el segundo número: '))
# Comparamos ambos números y determinamos cuál es el mayor
if num1 > num2:
    print(f'El primer número es mayor: {num1}')
elif num2 > num1:
    print(f'El segundo número es mayor: {num2}')
else: # En caso de que los números sean iguales
    print('Ambos números son iguales.')
Copia el código
2 -

# Recolectamos el porcentaje
variación = float(input('Ingrese el porcentaje de crecimiento: ')
# Verificamos si el valor es positivo o negativo con una comparación para ver si el número
# es mayor o menor que 0
if variación > 0:
    print(f'Hubo un crecimiento del {variación}%')
elif variación < 0:
    print(f'Hubo un decrecimiento del {variación}%')
else:
    print('No hubo crecimiento ni decrecimiento.')
Copia el código
3 - Podemos verificar si una letra es una vocal o una consonante al comprobar si el carácter está contenido en una cadena de vocales utilizando el operador in.

# Recolectamos la letra del usuario en minúsculas
letra = input('Ingrese una letra: ').lower()
vocales = 'aeiou' # cadena que contiene todas las vocales
# Verificamos si la letra está en las vocales con `in`
if letra in vocales:
    print('La letra es una vocal.')
else:
    print('La letra es una consonante.')
Copia el código
4 - Comparamos cada valor con los otros dos valores correspondientes a los otros dos años y determinamos el valor más alto y el más bajo. Lo hacemos asignando inicialmente el valor de precio_ano1 como el valor máximo y, si encontramos un valor mayor, actualizamos la variable mayor. Utilizamos una lógica similar para encontrar el valor mínimo.

# Recolectamos los precios de los 3 años
precio_ano1 = float(input('Ingrese el precio promedio del automóvil en el primer año: '))
precio_ano2 = float(input('Ingrese el precio promedio del automóvil en el segundo año: '))
precio_ano3 = float(input('Ingrese el precio promedio del automóvil en el tercer año: '))
# Determinamos el valor más alto mediante comparaciones
mayor = precio_ano1
if precio_ano2 > mayor:
  mayor = precio_ano2
if precio_ano3 > mayor:
  mayor = precio_ano3
# Determinamos el valor más bajo mediante comparaciones
menor = precio_ano1
if precio_ano2 < menor:
  menor = precio_ano2
if precio_ano3 < menor:
  menor = precio_ano3
# Mostramos los resultados
print(f'El precio más alto fue de R$ {mayor}.')
print(f'El precio más bajo fue de R$ {menor}.')
Copia el código
5 -

# Recolectamos el precio de tres productos
producto1 = float(input('Ingrese el precio del primer producto: '))
producto2 = float(input('Ingrese el precio del segundo producto: '))
producto3 = float(input('Ingrese el precio del tercer producto: '))

# Usamos el operador lógico `and` para determinar cuál es el precio más bajo entre los 3 productos
# ya que esto nos permite hacer una comparación de 3 entradas
if producto1 < producto2 and producto1 < producto3:
    print('El primer producto es el más barato.')
elif producto2 < producto1 and producto2 < producto3:
    print('El segundo producto es el más barato.')
else:
    print('El tercer producto es el más barato.')
Copia el código
6 - Después de recolectar los 3 números, realizamos comparaciones siguiendo una lógica similar a la pregunta anterior. Utilizamos el operador lógico and para determinar cuál es el número más grande entre los 3 datos de productos, luego verificamos entre los dos más pequeños y finalmente utilizamos print para mostrar los números en orden descendente mediante varias declaraciones condicionales anidadas.

# Recolectamos los 3 números
num1 = int(input('Ingrese el primer número: '))
num2 = int(input('Ingrese el segundo número: '))
num3 = int(input('Ingrese el tercer número: '))

# Comparación entre los 3 números
if (num1 >= num2) and (num1 >= num3):
    print(num1)
    if num2 >= num3:
        print(num2)
        print(num3)
    else:
        print(num3)
        print(num2)
elif (num2 >= num1) and (num2 >= num3):
    print(num2)
    if num1 >= num3:
        print(num1)
        print(num3)
    else:
        print(num3)
        print(num1)
else:
    print(num3)
    if num1 >= num2:
        print(num1)
        print(num2)
    else:
        print(num2)
        print(num1)
Copia el código
7 -

# Recolectamos el turno de estudio
turno = input('Ingresa en qué turno estudias (mañana, tarde o noche): ')

# Comparamos la entrada con todas las opciones y mostramos el resultado.
if turno == 'mañana':
  print('¡Buenos Días!')
elif turno == 'tarde':
  print('¡Buenas Tardes!')
elif turno == 'noche':
  print('¡Buenas Noches!')
else:
  print('¡Valor Inválido!')
Copia el código
8 - Podemos usar el operador de módulo % para determinar si un número es par o impar. Si la división entera de un número entre 2 da como resultado 0, entonces es par. Si no, es impar. Esto se debe a que todos los números pares son divisibles por 2, por lo que no tienen un residuo en la división.

# Recolectamos los datos
num = int(input('Ingresa un número: '))

# Verificamos si el número es par según el resultado del módulo
if num % 2 == 0:
    print('El número es par.')
else:
    print('El número es impar.')
Copia el código
9 - Podemos usar el operador de módulo % para determinar si un número es entero o decimal. Si el operador de módulo % devuelve cero en la división entera de un número entre 1, entonces es un número entero. De lo contrario, es un número decimal.

# Recolectamos los datos
num = float(input('Ingresa un número: '))
# Verificamos si el número es entero o decimal según el resultado del módulo
si num % 1 == 0:
    print('El número es entero.')
else:
    print('El número es decimal.')
Copia el código
10 -

# Recolectamos los números a operar y solicitamos la operación deseada por el usuario
num1 = float(input('Ingrese el primer número: '))
num2 = float(input('Ingrese el segundo número: '))
operación = input('Ingrese la operación deseada (+, -, *, /): ')

# Verificamos la operación seleccionada y realizamos la operación matemática según la elección
if operación == '+':
    resultado = num1 + num2
elif operación == '-':
    resultado = num1 - num2
elif operación == '*':
    resultado = num1 * num2
elif operación == '/':
    resultado = num1 / num2
else: # Especificamos un resultado en caso de que el usuario no ingrese una de las operaciones correctamente.
    print('Operación no válida, el resultado de la operación será 0')
    resultado = 0 

# Realizamos las mismas verificaciones que en preguntas anteriores para generar el informe del cálculo entre números
if resultado % 1 == 0:
    print('El resultado es un número entero.')
else:
    print('El resultado es un número decimal.')

si el resultado > 0:
    print('El resultado es positivo.')
else:
    print('El resultado es negativo.')

si el resultado % 2 == 0:
    print('El resultado es un número par.')
else:
    print('El resultado es un número impar.')
Copia el código
11 - Después de recolectar los valores de los 3 lados de un triángulo, debemos verificar si realmente pueden formar un triángulo siguiendo el consejo "Tres lados forman un triángulo cuando la suma de cualquier par de lados es mayor que el tercer lado". Esta verificación se puede realizar con el operador "and". Luego, podemos verificar si todos los lados son iguales, lo que forma un triángulo equilátero, o si todos los lados son diferentes, lo que forma un triángulo escaleno. Estas verificaciones se pueden realizar con el operador "and" y los operadores "== y "! =". Finalmente, utilizamos "else" para el caso de un triángulo isósceles.

# Recolectamos los lados de un triángulo
print('Estamos recopilando los lados de un triángulo.')
lado1 = float(input('Ingresa la longitud del primer lado: '))
lado2 = float(input('Ingresa la longitud del segundo lado: '))
lado3 = float(input('Ingresa la longitud del tercer lado: '))

# Verificamos si los lados pueden formar un triángulo
if (lado1 + lado2 > lado3) and (lado2 + lado3 > lado1) and (lado1 + lado3 > lado2):
    print('¡Los valores pueden formar un triángulo!')
    # Comparamos los lados para determinar el tipo de triángulo
    if (lado1 == lado2) and (lado2 == lado3):
        print('El triángulo es equilátero.')
    elif (lado1 != lado2) and (lado2 != lado3) and (lado1 != lado3):
        print('El triángulo es escaleno.')
    else:
        print('El triángulo es isósceles.')
else:
    print('¡Los valores no pueden formar un triángulo!')
Copia el código
12 -

# Recolectamos la cantidad de litros y el tipo de combustible,
# convirtiendo el carácter en mayúsculas para facilitar nuestro análisis
cantidad_litros = float(input('Ingrese la cantidad de litros vendidos: '))
tipo_combustible = input('Ingrese el tipo de combustible (E para etanol y D para diésel): ').upper()

# Verificamos primero el tipo de combustible
if tipo_combustible == 'E':
  # Establecemos el precio por litro de etanol
  precio_litro = 1.70
  # Según la cantidad de litros, establecemos el descuento correspondiente
  if cantidad_litros <= 15:
    descuento = 0.02
  else:
    descuento = 0.04
elif tipo_combustible == 'D':
  # Establecemos el precio por litro de diésel
  precio_litro = 2.00
  # Según la cantidad de litros, establecemos el descuento correspondiente
  if cantidad_litros <= 15:
    descuento = 0.03
  else:
    descuento = 0.05
# En caso de error en la especificación del tipo de combustible,
# consideramos las entradas como no válidas y establecemos los precios y descuentos en 0
else:
    print('Entradas no válidas!')
    precio_litro = 0
    descuento = 0

# Calculamos el valor del descuento, seguido del cálculo del precio descontado
valor_descuento = precio_litro * cantidad_litros * descuento
valor_pagado = precio_litro * cantidad_litros - valor_descuento

# Resultado
print(f'Valor a pagar por el cliente: R$ {valor_pagado}')COPIAR CÓDIGO
Copia el código
13 -

# Recolectamos las ventas de los dos años
venta_2022 = float(input('Ingrese la cantidad de ventas en 2022: '))
venta_2023 = float(input('Ingrese la cantidad de ventas en 2023: '))

# Calculamos la variación porcentual entre las ventas de los años 2022 y 2023
var_porcentual = 100 * (venta_2023 - venta_2022) / (venta_2022)

# Análisis condicional de la variación porcentual para determinar la sugerencia a enviar
if var_porcentual > 20:
    print('Bonificación para el equipo de ventas.')
elif 2 <= var_porcentual <= 20:
    print('Pequeña bonificación para el equipo de ventas.')
elif -10 <= var_porcentual < 2:
    print('Planificación de políticas de incentivo a las ventas.')
else:
    print('Recorte de gastos.')
Copia el código
Ejercitarse es importante para consolidar el contenido, desarrollar habilidades de codificación, identificar puntos que aún no se han comprendido, prepararse para desafíos futuros, desarrollar el pensamiento lógico y la resolución de problemas.

Teniendo esto en cuenta, es interesante realizar muchos ejercicios cuando se está aprendiendo un nuevo lenguaje de programación. Por lo tanto, busca completar los ejercicios propuestos y observa cómo te ayudan a progresar en tus habilidades de codificación.

Si tienes alguna pregunta, puedes comunicarte en el foro.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
13
Lo que aprendimos
 Siguiente pregunta

Lo que aprendimos en esta aula:

Construir estructuras condicionales con if, else y elif.
Diferenciar las estructuras condicionales.
Seleccionar la estructura condicional que mejor se adapte al problema.
Utilizar diferentes operadores para crear expresiones condicionales.
*********************************************************************
********************************************************************
04. Estructuras de Repetición o Ciclos
01
Proyecto del aula anterior
 Siguiente pregunta

¿Comenzando en esta etapa? Aquí puedes descargar los archivos del proyecto que hemos avanzado hasta el aula anterior.

Descargue los archivos en Github o haga clic aquí para descargarlos directamente.
************************************************************
02
Estructuras de repetición
02
En esta clase, aprendimos sobre las estructuras de repetición en Python, específicamente cómo calcular el promedio de dos calificaciones para tres estudiantes. Comenzamos creando variables para almacenar las calificaciones, que pueden ser de tipo flotante. Luego, ingresamos las calificaciones de cada estudiante y calculamos el promedio sumando las dos calificaciones y dividiendo el resultado entre dos.

Sin embargo, se destacó que repetir el mismo código para cada estudiante no es práctico, especialmente si tuviéramos que hacerlo para un gran número de estudiantes. Por lo tanto, se introdujo la idea de utilizar bucles de repetición, como el bucle while y el bucle for, para automatizar este proceso y evitar la repetición manual del código. En la próxima clase, exploraremos estos bucles con más detalle.
**********************************************************************+
03 Lazo While
En esta clase, aprendimos sobre el lazo de repetición while en Python, que nos permite ejecutar un bloque de código mientras una condición sea verdadera. La sintaxis es sencilla: comenzamos con while, seguido de la condición y el bloque de código que queremos repetir.

Se presentó un ejemplo práctico de un contador que imprime los números del uno al diez. Para ello, inicializamos un contador en uno y utilizamos la condición de que el contador sea menor o igual a diez. En cada iteración, incrementamos el contador en uno. También se mostró una forma más elegante de hacerlo utilizando +=, que es una característica de Python.

Finalmente, se mencionó que se puede aplicar el mismo concepto para recoger notas y promedios de estudiantes dentro de un bucle while. Esto nos permite manejar repeticiones de manera más eficiente y clara en nuestro código.

Si tienes alguna pregunta específica o necesitas más detalles sobre algún aspecto, ¡estaré encantado de ayudarte!
************************************************+
04
Para saber más: operadores de atribución
 Siguiente pregunta

Los operadores de asignación permiten asignar un valor a una variable. Ya hemos trabajado bastante con el principal en Python, que es el operador "=" que realiza una asignación literal de un valor a una variable, como en "edad = 20" o "escolaridad = 'superior'", etc.

También conocemos el operador de suma "+=" que agrega un valor especificado a la variable, como se muestra en el siguiente ejemplo:

precio = 2.00
precio += 3
print(precio)
Copia el código
Salida: 5.0

Además de estos, existen otros operadores de asignación que permiten modificar los valores de las variables. Puede encontrar información sobre los operadores, su descripción y ejemplos en la siguiente tabla:

Operador	Descripción											Ejemplo
-=	Resta un valor de la variable precio									-= 5
*=	Multiplica un valor por la variable precio								*= 3
/=	Divide la variable por un valor precio									/= 2
//=	Realiza una división entera de la variable por un valor precio						//= 6
%=	Calcula el resto de la división del valor en la variable y asigna el resultado a la variable precio	%= 5
********************************************************************************
05
¿Para qué sirven los lazos?
 Siguiente pregunta

Estructuras de repetición, como el "while," permiten la ejecución repetida de un bloque de comandos. Para el "while," el bloque se repite mientras una cierta condición sea verdadera. En el contexto de Ciencia de Datos, los bucles pueden contribuir significativamente a un estudio basado en datos. Con esto en mente, elija la alternativa que contiene una aplicación en Ciencia de Datos que tenga sentido utilizar una estructura de repetición.

Alternativa correta
Podemos utilizar una estructura de repetición cuando tenemos un gran volumen de datos que necesitan ser analizados elemento por elemento. En este caso, es interesante utilizar bucles para leer y procesarlos de manera rápida.


Cuando los datos son grandes, los bucles pueden ser una opción muy lenta para la lectura y procesamiento de cada dato. Además, pueden consumir una gran cantidad de potencia de procesamiento de la máquina o servidor responsable de la aplicación.

Alternativa correta
El bucle se puede utilizar para leer y manipular un conjunto pequeño de datos. Por ejemplo, al recibir un conjunto de datos relacionados con las ventas anuales de una empresa, se puede utilizar el bucle para leer el conjunto elemento por elemento y realizar un análisis sobre cómo calcular el promedio de ventas en cada mes.


Con un bucle, podemos iterar sobre un conjunto de datos y realizar alguna operación en cada elemento. Esto es muy útil porque a veces los datos que estamos analizando necesitan ser limpiados o formateados antes de ser utilizados. Por lo tanto, un bucle que permita realizar este proceso de manera automática y rápida es muy útil y tiene mucho sentido.

Alternativa correta
El uso de bucles se recomienda ampliamente en el análisis de datos que llegan en tiempo real o en flujo continuo. Como ejemplo, se pueden mencionar las transacciones financieras, los tweets y los sensores IoT (Internet de las cosas).


Al trabajar con datos que llegan en tiempo real, es importante procesar esos datos también en tiempo real, para emitir alertas o acciones inmediatas, por ejemplo. Los bucles pueden generar retrasos y crear cuellos de botella en el procesamiento de múltiples datos en tiempo real, por lo que no son aplicaciones interesantes en este caso.

¡Enhorabuena, has acertado!
**********************************************************************************
06
Lazo For
el lazo FOR en Python, que nos permite iterar sobre un conjunto de elementos de manera controlada. A diferencia del lazo WHILE, en el FOR debemos especificar sobre qué elementos queremos iterar. La estructura básica es FOR elemento IN conjunto: y dentro del bloque se ejecuta el código para cada elemento.

También se introdujo la función RANGE, que genera una secuencia de números enteros. Esta función tiene tres parámetros: inicio, fin y paso. Es importante recordar que el inicio es inclusivo y el fin es exclusivo, lo que significa que si queremos incluir el número 10, debemos establecer el rango hasta 11. Si no especificamos el paso, el valor predeterminado es 1.

Finalmente, se mostró cómo utilizar el lazo FOR junto con RANGE para imprimir los números del 1 al 10, destacando que no es necesario definir un contador manualmente, ya que el lazo se encarga de ello automáticamente.

Copiar texto de Luri al portapapeles
Limpiar conversación
****************************************************************************
07 ¿Qué es el lazo for?
 Siguiente pregunta

Aprendimos sobre la estructura de repetición "for" en clase. Elige la alternativa que describa qué hace el "for" y muestra un ejemplo con su estructura.

Alternativa correta
El "for" es una estructura de repetición que permite la iteración sobre un conjunto de elementos. Debido a que es solo una iteración, se ejecuta más rápidamente que el bucle "while." Como ejemplo, tenemos la creación de un código que permite descubrir la cantidad total de propiedades construidas entre los años 2017 y 2022 por una inmobiliaria.

total_propiedades = 0

for año in range(2017, 2023):
cantidad_propiedades = float(input(f'Digite la cantidad de propiedades en el año {año}: '))
total_propiedades += cantidad_propiedades

print(f'Total de propiedades construidas: {total_propiedades} propiedades')

Alternativa correta
El "for" es una estructura de repetición que permite ejecutar un bloque de código repetidamente mientras una condición dada sea verdadera. Como ejemplo, tenemos la creación de un código que permite descubrir la cantidad total de propiedades construidas entre los años 2017 y 2022 por una inmobiliaria.

total_propiedades = 0
año = 2017

while año <= 2022:
cantidad_propiedades = float(input(f'Digite la cantidad de propiedades en el año {año}: '))
total_propiedades += cantidad_propiedades
año += 1

print(f'Total de propiedades construidas: {total_propiedades} propiedades')

Alternativa correta
El "for" es una estructura de repetición que permite iterar sobre un conjunto de elementos. Para nuestro ejemplo, podemos crear un código que permite descubrir la cantidad total de propiedades construidas entre los años 2017 y 2022 por una inmobiliaria.

total_propiedades = 0

for año in range(2017, 2023):
cantidad_propiedades = float(input(f'Digite la cantidad de propiedades en el año {año}: '))
total_propiedades += cantidad_propiedades

print(f'Total de propiedades construidas: {total_propiedades} propiedades')

El "for" itera sobre cada elemento del conjunto especificado y ejecuta el bloque de código dentro del bucle para cada elemento. Cuando el bucle llega al final del conjunto, se detiene. En el ejemplo, el conjunto iterado es el rango que funciona como un contador de 2017 a 2022, recopilando la cantidad de propiedades y sumándolas al total en cada iteración. Cuando se han recorrido todos los elementos en la secuencia del rango, el bucle se detiene.

¡Enhorabuena, has acertado!
 Discutir en el Foro
*******************************************************************************+
 08 Para saber más: comandos de control
 Siguiente pregunta

Cuando trabajamos con bucles, podemos controlar el flujo de ejecución dentro del bloque de código, lo que nos permite manipular la ejecución de los bucles. continue y break son los comandos de control que podemos usar con los bucles for y while.

continue interrumpe la iteración actual del bucle y salta a la siguiente, es decir, regresa al inicio del código. Como ejemplo, aquí hay un código que cuenta del 1 al 5 con un bucle for:

for i in range(1, 6):
    if i == 4:
        continue
    print(i)
Copia el código
Este código imprime todos los números del 1 al 5, excepto el 4. Cuando el valor de i es 4, continue salta a la siguiente iteración, omitiendo la instrucción print después de la condición en la iteración actual.

Por otro lado, break detiene por completo la ejecución del bucle, saliendo del bloque de código. Utilicemos el mismo ejemplo de conteo, pero esta vez con break:

for i in range(1, 6):
    if i == 4:
        break
    print(i)
Copia el código
En este caso, el código imprime todos los números del 1 al 3. Cuando el valor de i es 4, break interrumpe por completo la ejecución del bucle y sale de él, ignorando cualquier otra iteración que esté dentro de la estructura.
*************************************************************************************************
09 Desafío: ¡Es hora de practicar!
 Siguiente pregunta

Vamos practicar el uso de estructuras de repetición como el "while" y el "for" a partir de algunas actividades. Ahora que estamos avanzando en el contenido, podemos hacer los desafíos más interesantes. ¡Para ello, trabajaremos en proyectos de código!

Comencemos resolviendo algunos problemas para calentar y prepararnos para los proyectos.

Entrenando la programación

1 - Escribe un programa que solicite dos números enteros e imprima todos los números enteros entre ellos.

2 - Escribe un programa para calcular cuántos días tomará que la colonia de una bacteria A supere o iguale a la colonia de una bacteria B, basado en tasas de crecimiento del 3% y 1.5%, respectivamente. Supón que la colonia A comienza con 4 elementos y B con 10.

3 - Para procesar una cantidad de 15 datos de evaluaciones de usuarios de un servicio de la empresa, necesitamos verificar si las calificaciones son válidas. Por lo tanto, escribe un programa que recibirá calificaciones del 0 al 5 y verificará si son valores válidos. Si se ingresa una calificación superior a 5 o inferior a 0, se repetirá hasta que el usuario ingrese un valor válido.

4 - Desarrolla un programa que lea un conjunto indefinido de temperaturas en grados Celsius y calcule su promedio. La lectura debe detenerse al ingresar el valor -273°C.

5 - Escribe un programa que calcule el factorial de un número entero proporcionado por el usuario. Recuerda que el factorial de un número entero es el producto de ese número por todos sus antecesores hasta llegar al número 1. Por ejemplo, el factorial de 5 es 5 x 4 x 3 x 2 x 1 = 120.

Momento de los proyectos

6 - Escribe un programa que genere la tabla de multiplicar de un número entero del 1 al 10, según la elección del usuario. Como ejemplo, para el número 2, la tabla de multiplicar debe mostrarse en el siguiente formato:

Tabla de multiplicar del 2:
2 x 1 = 2
2 x 2 = 4
[...]
2 x 10 = 20
Copia el código
7 - Los números primos tienen diversas aplicaciones en Ciencia de Datos, como en criptografía y seguridad. Un número primo es aquel que es divisible solo por sí mismo y por 1. Por lo tanto, crea un programa que solicite un número entero y determine si es un número primo o no.

8 - Vamos a comprender la distribución de edades de los pensionistas de una empresa de seguros. Escribe un programa que lea las edades de una cantidad no informada de clientes y muestre la distribución en los intervalos [0-25], [26-50], [51-75] y [76-100]. La entrada de datos se detendrá al ingresar un número negativo.

9 - En una elección para la gerencia de una empresa con 20 empleados, hay cuatro candidatos. Escribe un programa que calcule al ganador de la elección. La votación se realizó de la siguiente manera:

Cada empleado votó por uno de los cuatro candidatos (representados por los números 1, 2, 3 y 4).

También se contaron los votos nulos (representados por el número 5) y los votos en blanco (representados por el número 6).

Al final de la votación, el programa debe mostrar el número total de votos para cada candidato, los votos nulos y los votos en blanco. Además, debe calcular y mostrar el porcentaje de votos nulos con respecto al total de votos y el porcentaje de votos en blanco con respecto al total de votos.

Si necesitas ayuda, las soluciones a las actividades están disponibles en la sección "Opinión del instructor".

Ver opinión del instructor
Opinión del instructor

Pueden existir diversas formas de resolver los problemas propuestos, y algunas de ellas se presentan a continuación.

Entrenando la programación

1 -

# Recolectamos los valores de inicio y fin
inicio = int(input('Ingresa el primer número entero: '))
fin = int(input('Ingresa el segundo número entero: '))

# Verificamos si el valor de inicio es menor que el fin
if inicio < fin:
  # Podemos imprimir los enteros entre el valor menor y el valor mayor
  for i in range(inicio + 1, fin): 
    print(i)
elif inicio > fin:
  for i in range(fin + 1, inicio):
    print(i)
else: # En caso de que los números sean iguales, no podemos imprimir ninguna secuencia.
  print('Los números son iguales.')
Copia el código
2 -

# Número inicial de bacterias
colonia_a = 4
colonia_b = 10

# Tasas de crecimiento de las colonias
tasa_a = 0.03
tasa_b = 0.015

# Contador de días
días = 0

# La condición que termina el bucle es cuando
# la colonia A supera a la colonia B
while colonia_a <= colonia_b:
  # Usamos un operador de asignación con multiplicación
  colonia_a *= 1 + tasa_a
  colonia_b *= 1 + tasa_b
  # Contamos los días en cada iteración
  días += 1

# Resultado final
print(f'Necesitará {días} días para que la colonia A supere a la colonia B.')
Copia el código
3 -

# Bucle para recopilar las 15 notas
for i in range(15):
  nota = float(input(f'Ingresa la nota del usuario {i}: ')

  # Verifica si la nota está entre 0 y 5
  # Si no lo está, el bucle se repetirá hasta que se obtenga un valor válido
  while (nota < 0) or (nota > 5):
    nota = float(input(f'Nota no válida, ingresa nuevamente la nota del usuario {i}: '))

print('Verificación completa. Todas las notas son válidas.')
Copia el código
4 -

# Recopilamos la temperatura
temperatura = float(input('Ingresa la temperatura en grados Celsius: '))

# Inicializamos un contador y una suma para calcular el promedio
contador = 0
suma = 0

# Nuestro código se ejecuta hasta que el valor de temperatura sea igual a -273
while temperatura != -273:
    # La suma se actualiza sumando la temperatura a la variable suma
    suma += temperatura
    # Contamos la cantidad de valores recopilados con el contador
    contador += 1
    # Recopilamos nuevamente la temperatura
    temperatura = float(input('Ingresa la temperatura en grados Celsius: '))

promedio = suma / contador

print(f'El promedio de las temperaturas es: {promedio}')
Copia el código
5 -

# Solicita el número
num = int(input('Ingresa un número entero: ')

# Inicializa el cálculo
factorial = 1

# Nuestro contador comienza con el número máximo
# y se realizará un conteo decreciente con el operador -=
i = num
while i > 0:
    # Queremos multiplicar el valor factorial por el número
    # y todos los números por debajo de él hasta 1
    factorial *= i
    i -= 1

# Imprime el cálculo del factorial
print(f'El factorial de {num} es {factorial}')

Momento de los proyectos
Copia el código
6 -

# Solicita el número
num = int(input('Ingresa un número entero del 1 al 10: ')

# Generamos la tabla de multiplicar
print(f'Tabla de multiplicar del {num}:')
for i in range(1, 11):
    resultado = num * i
    print(f'{num} x {i} = {resultado}')
Copia el código
7 -

# Recopilamos el número
num = int(input('Ingresa un número entero: ')

# Los números enteros iguales o menores que 1 no se consideran primos
if num > 1:
    for i in range(2, num):
        # Verificamos todos los residuos de la división entre todos los números menores que num
        # Si algún residuo es 0, significa que es divisible por otro número además de sí mismo y 1
        if (num % i) == 0:
            print(f'{num} no es un número primo')
            break
    else:
        print(f'{num} es un número primo')
else:
    print(f'{num} no es un número primo')
Copia el código
8 -

# Recopilamos las edades de los clientes
edad = int(input('Ingresa la edad (o un número negativo para finalizar): ')

# Inicializamos las variables de conteo
contador_0_25 = 0 # contador de edades entre 0 y 25
contador_26_50 = 0 # contador de edades entre 26 y 50
contador_51_75 = 0 # contador de edades entre 51 y 75
contador_76_100 = 0 # contador de edades entre 76 y 100

# Nuestro código se ejecuta hasta que el valor de edad sea negativo
while edad >= 0:
    # Contamos cada caso
    if edad >= 0 and edad <= 25:
        contador_0_25 += 1
    elif edad >= 26 and edad <= 50:
        contador_26_50 += 1
    elif edad >= 51 and edad <= 75:
        contador_51_75 += 1
    elif edad >= 76 and edad <= 100:
        contador_76_100 += 1
    
    # Repetimos el proceso de entrada de datos hasta que se ingrese un número negativo    
    edad = int(input('Ingresa la edad (o un número negativo para finalizar): ')

# Mostramos los resultados
print('Distribución de edades:')
print('[0-25]:', contador_0_25)
print('[26-50]:', contador_26_50)
print('[51-75]:', contador_51_75)
print('[76-100]:', contador_76_100)
Copia el código
9 -

# Inicializamos las variables contadoras
votos_candidato1 = 0
votos_candidato2 = 0
votos_candidato3 = 0
votos_candidato4 = 0
votos_nulos = 0
votos_blanco = 0

# Inicio del bucle para leer los votos
for i in range(0, 20):
    voto = int(input('Ingresa tu voto: ')
    if voto == 1:
        votos_candidato1 += 1
    elif voto == 2:
        votos_candidato2 += 1
    elif voto == 3:
        votos_candidato3 += 1
    elif voto == 4:
        votos_candidato4 += 1
    elif voto == 5:
        votos_nulos += 1
    elif voto == 6:
        votos_blanco += 1
    else:
        print("Voto inválido.")

print(f'Votos candidato 1: {votos_candidato1}')
print(f'Votos candidato 2: {votos_candidato2}')
print(f'Votos candidato 3: {votos_candidato3}')
print(f'Votos candidato 4: {votos_candidato4}')
print(f'Votos nulos: {votos_nulos}')
print(f'Votos en blanco: {votos_blanco}')
print(f'Porcentaje de votos nulos: {(votos_nulos / 20 * 100)}')
print(f'Porcentaje de votos en blanco: {(votos_blanco / 20 * 100)}')
Copia el código
Ejercitar es importante para afianzar el contenido, desarrollar habilidades de programación, identificar áreas que aún no se comprenden, prepararse para futuros desafíos y desarrollar el pensamiento lógico y la resolución de problemas.

Por lo tanto, es importante realizar muchos ejercicios cuando se está aprendiendo un nuevo lenguaje de programación. Por lo tanto, busca practicar con los ejercicios propuestos y observa cómo te ayudan a mejorar tus habilidades de programación.

Si tienes alguna pregunta, puedes utilizar el foro o nuestra comunidad en Discord.

*********************************************************************************************************************
10 Lo que aprendimos
 Siguiente pregunta

Lo que aprendimos en esta aula:

Estructurar bucles de repetición for y while.
Decidir qué bucle de repetición utilizar.
Utilizar comandos de control de bucles.
******************************************************************
***********************************************************************
05. Estructura de datos
01
Proyecto del aula anterior
*********************************************
02
Listas
¡Por supuesto! En esta clase, exploramos las listas en Python, que son colecciones de elementos organizados y mutables. Aprendimos que:

Creación de listas: Se crean usando corchetes [] y los elementos se separan por comas. Pueden contener diferentes tipos de datos, como números, cadenas de texto, y más.

Índices: Cada elemento en una lista tiene un índice que comienza en 0. También se pueden usar índices negativos para acceder a los elementos desde el final de la lista.

Acceso a elementos: Podemos acceder a los elementos de la lista utilizando su índice y también verificar el tipo de datos de cada elemento.

Iteración: Se puede recorrer una lista utilizando un bucle for, lo que permite imprimir o manipular cada elemento de manera dinámica.

Modificación de elementos: Se puede cambiar el valor de un elemento en la lista asignando un nuevo valor a su índice.

Cálculo de promedios: Aprendimos a calcular el promedio de ciertos elementos de la lista sumando los valores y dividiendo por la cantidad de elementos.

Si necesitas más información o ejemplos sobre algún punto específico, ¡estaré encantado de ayudarte!
**********************************************************************+
 03 Para saber más: String - Una secuencia de caracteres
 Siguiente pregunta

Como se ha visto en clases anteriores, una cadena es un tipo de dato que corresponde a datos de texto. Cuando creamos una cadena, estamos agrupando varios caracteres (números, letras e incluso símbolos), y cada uno de ellos tiene sus índices. Como ejemplo, creemos una cadena con el nombre "Python":

lenguaje = 'Python'
Copia el código
Cada carácter de la cadena "lenguaje" se puede acceder mediante su índice, que comienza en 0 y va hasta la cantidad de caracteres de la cadena menos 1, incluyendo índices negativos. Podemos acceder a ellos de la misma manera que lo hacemos con las listas:

print(lenguaje[0], lenguaje[1], lenguaje[2], lenguaje[-3], lenguaje[-2], lenguaje[-1])
Copia el código
Salida: P y t h o n

Sin embargo, los índices solo se utilizan para acceder a los datos y no se puede cambiar el carácter presente en un índice específico mediante una simple asignación, como se hace con las listas. Por ejemplo, el código lenguaje[0] = 'p' generará un error en la compilación.

Con esto en mente, podríamos pensar que una cadena es una estructura de datos similar a una lista, ¿verdad? En realidad, no lo es. Una cadena es una secuencia de caracteres (letras, números, símbolos, etc.) representada por una sola variable. Por otro lado, una estructura de datos almacena una colección de elementos (que pueden ser de diferentes tipos) en una sola variable.

Sin embargo, es posible convertir una cadena en una lista mediante el método split(). Este método divide la cadena en una lista de cadenas, utilizando un delimitador especificado entre paréntesis. Este delimitador debe ser una cadena. Como ejemplo, convirtamos la cadena en una lista dividiéndola cada vez que aparezca el signo de interrogación "?":

pregunta = '¿Quién vino primero? ¿El huevo? ¿O fue la serpiente?'
lista_palabras = pregunta.split('?')
print(lista_palabras)
Copia el código
Salida: ['¿Quién vino primero', ' ¿El huevo', ' ¿O fue la serpiente', '']

El delimitador no aparece en la separación. Si no se define un delimitador, la cadena se separará por todos los espacios en blanco en el texto.

pregunta = '¿Quién vino primero? ¿El huevo? ¿O fue la serpiente?'
lista_palabras = pregunta.split()
print(lista_palabras)
Copia el código
Salida: ['¿Quién', 'vino', 'primero?', '¿El', 'huevo?', '¿O', 'fue', 'la', 'serpiente?']

Lo contrario también es posible, ya que podemos convertir una lista en una cadena mediante el método join(). Para usar esta función, debemos definir el carácter que se utilizará para unir los elementos de la lista y formar la cadena. Luego, usamos el método { join() pasando la lista como argumento. Veamos un ejemplo con una lista que contiene el resultado de algunas mezclas de colores primarios en pintura:

mezclas = ['Pinturas: rojo, azul y amarillo',
            'Verde: mezcla de azul y amarillo',
            'Naranja: mezcla de rojo y amarillo',
            'Morado: mezcla de rojo y azul']
unificador = '. '
cadena_mezclas = unificador.join(mezclas)
print(cadena_mezclas)
Copia el código
Salida: 'Pinturas: rojo, azul y amarillo. Verde: mezcla de azul y amarillo. Naranja: mezcla de rojo y amarillo. Morado: mezcla de rojo y azul'
********************************************************************
 04 ¿Qué son listas?
 Siguiente pregunta

Durante la clase, aprendimos acerca de un tipo de dato estructurado: las listas. Selecciona la opción que describe lo que son y proporciona un ejemplo de su estructura.

Alternativa correta
Las listas pueden almacenar una colección de elementos en orden. Una vez creadas, no pueden modificarse. Se delimitan con corchetes [] y los elementos se separan por comas. En el siguiente ejemplo, tenemos una lista con códigos de productos:

lista = ['A7B6C5', 'D4E3F2', 'G1H9I8', 'J6K5L4', 'M3N2O1', 'P9Q8R7']
print(lista)

Alternativa correta
Las listas pueden almacenar una única colección de elementos del mismo tipo en orden. Se delimitan con corchetes [] y los elementos se separan por comas. Por ejemplo, aquí tienes una lista con códigos de productos:

lista = ['A7B6C5', 'D4E3F2', 'G1H9I8', 'J6K5L4', 'M3N2O1', 'P9Q8R7']
print(lista)

Alternativa correta
Las listas pueden almacenar una colección de elementos de cualquier tipo en orden. Se delimitan con corchetes [] y los elementos se separan por comas. En el siguiente ejemplo, tenemos una lista con códigos de productos:

lista = ['A7B6C5', 'D4E3F2', 'G1H9I8', 'J6K5L4', 'M3N2O1', 'P9Q8R7']
print(lista)

Las listas pueden almacenar valores de manera ordenada en su estructura, de modo que cada elemento de la lista tiene un índice que indica su posición. En este ejemplo, tenemos 6 elementos con índices que van desde 0 hasta 5, en orden. Podemos acceder a cada elemento por separado utilizando sus respectivos índices.
**********************************************************************************+
05 Manipulación de listas
En esta clase, aprendimos sobre la manipulación de listas en Python, centrándonos en algunos métodos clave. Comenzamos con el método len, que nos permite conocer la cantidad de elementos en una lista. Luego, exploramos la notación de corte (slice notation), que nos ayuda a seleccionar porciones de la lista utilizando corchetes.

Vimos cómo tomar elementos específicos, como un subconjunto de la lista, y cómo acceder a todos los elementos. También aprendimos sobre el método append, que añade un solo elemento al final de la lista, y el método extend, que permite añadir múltiples elementos al final. Es importante notar que append agrega una lista como un solo elemento, mientras que extend añade cada elemento individualmente.

Finalmente, discutimos el método remove, que se utiliza para eliminar un elemento específico de la lista. Se enfatizó la importancia de consultar la documentación para conocer más métodos y experimentar con ellos. En la próxima clase, se abordará el tema de los diccionarios, otra colección importante en Python.
*********************************************************************************
06 Para saber más: otras manipulaciones para las listas
 Siguiente pregunta

Hemos estudiado algunos métodos en clase, y además de esos, podemos utilizar otros para manipular listas en Python. Vamos a conocerlos y ver ejemplos de cómo se utilizan. En todos los casos, utilizaremos la siguiente lista llamada "razas_de_perros":

razas_de_perros = ['Labrador Retriever',
                   'Bulldog Francés',
                   'Pastor Alemán',
                   'Poodle']
Copia el código
El primer método es insert(), que permite insertar un elemento en una posición específica de la lista. La sintaxis es lista.insert(indice, elemento), donde "lista" es la lista que recibirá el nuevo elemento, "indice" es la posición donde se insertará el nuevo elemento y "elemento" es el nuevo elemento que se insertará.

razas_de_perros.insert(1, 'Golden Retriever')
razas_de_perros
Copia el código
Salida: ['Labrador Retriever', 'Golden Retriever', 'Bulldog Francés', 'Pastor Alemán', 'Poodle']

Siguiendo este enfoque, la estructura lista.insert(len(lista), elemento) es equivalente al uso del método append(), como vimos en el video anterior titulado "Manipulación de listas".

El método pop() elimina el elemento en una posición específica de la lista y lo devuelve como salida al ejecutar el método. Solo necesitamos especificar, entre paréntesis, el índice del elemento que deseamos eliminar, y se eliminará de la lista. Por lo tanto, eliminemos la raza "Golden Retriever" que agregamos en el método anterior.

razas_de_perros.pop(1)
Copia el código
Salida: 'Golden Retriever'

El método index() devuelve el índice de un elemento específico en la lista. Para hacerlo, especificamos el elemento entre paréntesis. Para encontrar el índice de la raza "Pastor Alemán" en la lista, hacemos lo siguiente:

razas_de_perros.index('Pastor Alemán')
Copia el código
Salida: 2

El método sort() ordena los elementos de la lista en orden ascendente o descendente. Si son palabras, el orden se basa en el orden alfabético o en el orden inverso. Para ordenar los valores, simplemente llamamos al método sort(), y la lista se organizará en orden. Para ordenar alfabéticamente la lista de razas de perros, podemos usar el siguiente código:

razas_de_perros.sort()
razas_de_perros
Copia el código
Salida: ['Bulldog Francés', 'Labrador Retriever', 'Pastor Alemán', 'Poodle']

Para obtener más opciones y descripciones de métodos, consulta la documentación de Python: https://docs.python.org/3/tutorial/datastructures.html#more-on-lists
***************************************************************************************
07
Diccionarios = {key: value}  # En JS el dict se llama mapa
En esta clase, aprendimos sobre los diccionarios, una estructura de datos en Python que permite almacenar datos en pares de clave-valor. A diferencia de las listas, que se crean con corchetes, los diccionarios se crean con llaves. La sintaxis básica consiste en definir una clave como una cadena de texto seguida de dos puntos y su valor correspondiente.

Se presentó un ejemplo práctico creando un diccionario llamado estudiante, que contiene información como matrícula, día de registro, mes de registro y grupo. También se mostró cómo acceder a los valores utilizando las claves y cómo modificar los valores de una clave existente, así como agregar nuevas claves y valores al diccionario.

Finalmente, se mencionó que existen métodos especiales que se pueden aplicar a los diccionarios, que se explorarán en la próxima clase.
**************************************************************************************************+
08
¿Qué son diccionarios?
 Siguiente pregunta

Aprendimos sobre una estructura de datos llamada diccionario. Selecciona la opción que describe su concepto y proporciona un ejemplo de su estructura.

Alternativa correta
Los diccionarios pueden almacenar valores de forma ordenada en su estructura, de modo que cada elemento de la lista tiene un índice numérico entero que indica su posición. Se delimitan con llaves {} y los elementos se separan por comas. Por ejemplo, el siguiente diccionario contiene los precios de productos en una tienda de ropa:

precios = {20, 30, 40, 50, 60, 5}
print(precios)

Alternativa correta
Los diccionarios son un tipo de estructura de datos que almacena pares clave-valor. Se delimitan con llaves {} y los pares clave-valor se separan por comas. Como ejemplo, podemos construir un diccionario que contiene los precios de productos en una tienda de ropa:

ropa = {'Camisa': 20, 'Pantalón': 30, 'Vestido': 40, 'Abrigo': 50, 'Zapatos': 60, 'Calcetines': 5}
print(ropa)

Los diccionarios pueden almacenar valores especificando sus claves. En ellos, la clave es un elemento único que identifica un valor en el diccionario, mientras que el valor es el elemento que se almacena para esa clave, como se muestra en el ejemplo. Las claves y los valores pueden ser de cualquier tipo de dato. Los diccionarios son útiles para almacenar y acceder a datos de manera organizada y rápida. Son un tipo de conjunto de elementos en Python, ya que almacenan una colección de elementos.

Alternativa correta
Los diccionarios son un tipo de estructura de datos que almacenan pares clave-valor. Los valores almacenados pueden ser de cualquier tipo, pero las claves solo pueden ser cadenas. Como ejemplo, tenemos el siguiente diccionario que contiene los precios de productos en una tienda de ropa:

ropa = {'Camisa': 20, 'Pantalón': 30, 'Vestido': 40, 'Abrigo': 50, 'Zapatos': 60, 'Calcetines': 5}
print(ropa)

Los diccionarios se indexan en función de las claves, formando pares clave-valor que pueden ser de cualquier tipo inmutable, como cadenas o números.
***************************************************************************************+
09
Profundizando en diccionarios
Claro! En esta clase, profundizamos en los diccionarios, que son estructuras de datos en Python que almacenan pares de clave-valor. Aprendimos varios métodos útiles para trabajar con diccionarios:

Método pop: Permite eliminar una clave específica de un diccionario y devuelve el valor asociado a esa clave.
Método items: Devuelve una lista de pares clave-valor en formato de tupla, lo que facilita la visualización de los elementos del diccionario.
Método keys: Devuelve una lista de todas las claves presentes en el diccionario.
Método values: Devuelve una lista de todos los valores asociados a las claves del diccionario.
También aprendimos a iterar sobre las claves y valores del diccionario utilizando un bucle for, lo que nos permite imprimir cada clave junto con su respectivo valor de una manera más visual.

Los diccionarios son herramientas muy poderosas y útiles en ciencia de datos, especialmente cuando se combinan con listas. ¡Espero que este resumen te ayude a repasar lo aprendido! Si tienes alguna pregunta o necesitas más detalles sobre algún punto, no dudes en preguntar.
**************************************************************************+
10 Para saber más: listas en diccionarios
 Siguiente pregunta

Podemos asociar estructuras de datos a otras estructuras de datos, como ocurre cuando tenemos listas dentro de diccionarios. En este caso, las listas pueden ser almacenadas en los valores de un diccionario de tal manera que cada clave puede tener una lista asociada a ella. Esto es útil cuando necesitamos almacenar varios valores relacionados con una sola clave. Por ejemplo, podemos construir un conjunto de datos de una tienda que contenga una clave con los nombres de cada producto y otra clave con los precios correspondientes, como se muestra en el código a continuación:

tienda = {'nombres': ['televisión', 'celular', 'notebook', 'geladeira', 'estufa'],
          'precios': [2000, 1500, 3500, 4000, 1500]}
Copia el código
Para acceder a los valores, podemos utilizar una estructura de bucles for:

for clave, elementos in tienda.items():
  print(f'Clave: {clave}\nElementos:')
  for dato in elementos:
    print(dato)
Copia el código
El primer bucle, el más externo, recorre los elementos dentro del diccionario (claves y elementos). Sabiendo que los elementos son listas, podemos acceder a los datos de las listas con otro bucle anidado que se encuentra dentro del primer bucle. El bucle más interno recorre los elementos de cada lista uno a uno e imprime los valores dentro de ellas.

Además, podemos realizar operaciones comunes en las listas, como agregar, eliminar o contar elementos en la lista asociada a una clave del diccionario. Puedes copiar los códigos anteriores y ejecutarlos en Colab para verificar la salida.
***************************************************************************
 11 Para saber más: funciones incorporadas
 Siguiente pregunta

Durante las clases, trabajamos directamente con varias funciones incorporadas que son predefinidas y están disponibles por defecto en Python. Estas funciones trabajan como herramientas útiles para llevar a cabo tareas comunes, como conversiones de tipos, operaciones matemáticas, manipulación de cadenas y más, sin necesidad de escribir código adicional.

Algunas de las funciones incorporadas que ya conocemos son: print(), input(), len(), int(), str(), float(), range(), chr(), etc. Pero hay otras además de estas que también son muy útiles, como: sum(), help() y dir(). ¿Las conocemos?

sum()

La función sum() permite sumar los elementos de una secuencia o estructura de datos. En el siguiente ejemplo, vamos a sumar los precios de productos:

precios = [100.0, 400.0, 200.0]
suma = sum(precios)
suma
Copia el código
Salida: 700.0

help()

La función help() se utiliza para acceder a la documentación de funciones, métodos y otros elementos de Python. Muestra información en inglés sobre la funcionalidad, sintaxis y uso de un objeto específico. Para usar esta función, simplemente pasa el elemento deseado entre paréntesis. Por ejemplo, vamos a verificar la documentación de la función print():

help(print)
Copia el código
Salida:

Help on built-in function print in module builtins:
print(...)
    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)
    
    Prints the values to a stream, or to sys.stdout by default.
    Optional keyword arguments:
    file:  a file-like object (stream); defaults to the current sys.stdout.
    sep:   string inserted between values, default a space.
    end:   string appended after the last value, default a newline.
    flush: whether to forcibly flush the stream.
Copia el código
dir()

Por último, la función dir() se utiliza para mostrar una lista de atributos y métodos asociados a un elemento. Por ejemplo, vamos a descubrir todos los atributos y métodos de una lista:

lista = [1,2,3]
dir(lista)
Copia el código
Salida:

['__add__', '__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
Copia el código
Es útil conocer varias funciones incorporadas y cómo funcionan, ya que ayudan mucho en la creación de código. Para obtener más información sobre las funciones, puedes consultar la documentación de Python.
***********************************************************************************
12 Desafío: ¡Es hora de practicar!
 Siguiente pregunta

Vamos practicar el uso de estructuras de datos, como listas y diccionarios, a través de algunas actividades. Ahora que estamos avanzando en el contenido, podemos hacer los desafíos más interesantes. ¡Para ello, trabajaremos con proyectos de código!

Primero, resolveremos algunos problemas para calentar y prepararnos para los proyectos.

Entrenando la programación

1 - Crea un programa que tenga la siguiente lista con los gastos de una empresa de papel [2172.54, 3701.35, 3518.09, 3456.61, 3249.38, 2840.82, 3891.45, 3075.26, 2317.64, 3219.08]. Con estos valores, crea un programa que calcule el promedio de gastos. Sugerencia: usa las funciones integradas sum() y len().

2 - Con los mismos datos de la pregunta anterior, determina cuántas compras se realizaron por encima de 3000 reales y calcula el porcentaje con respecto al total de compras.

3 - Crea un código que recoja en una lista 5 números enteros aleatorios e imprima la lista. Ejemplo: [1, 4, 7, 2, 4].

4 - Recoge nuevamente 5 números enteros e imprime la lista en orden inverso al enviado.

5 - Crea un programa que, al ingresar un número cualquiera, genere una lista que contenga todos los números primos entre 1 y el número ingresado.

6 - Escribe un programa que pida una fecha, especificando el día, mes y año, y determine si es válida para su análisis.

Momento para los proyectos

7 - Para un estudio sobre la multiplicación de bacterias en una colonia, se recopiló el número de bacterias multiplicadas por día y se puede observar a continuación: [1.2, 2.1, 3.3, 5.0, 7.8, 11.3, 16.6, 25.1, 37.8, 56.9]. Con estos valores, crea un código que genere una lista que contenga el porcentaje de crecimiento de bacterias por día, comparando el número de bacterias en cada día con el número de bacterias del día anterior. Sugerencia: para calcular el porcentaje de crecimiento, utiliza la siguiente ecuación: 100 * (muestra_actual - muestra_anterior) / muestra_anterior.

8 - Para una selección de productos alimenticios, debemos separar el conjunto de IDs proporcionados por números enteros, sabiendo que los productos con ID par son dulces y los que tienen ID impar son amargos. Crea un código que recoja 10 IDs. Luego, calcula y muestra la cantidad de productos dulces y amargos.

9 - Desarrolla un programa que informe la puntuación de un estudiante de acuerdo con sus respuestas. Debe pedir la respuesta del estudiante para cada pregunta y verificar si la respuesta coincide con el resultado. Cada pregunta vale un punto y hay opciones A, B, C o D.

Resultado del examen:
01 - D
02 - A
03 - C
04 - B
05 - A
06 - D
07 - C
08 - C
09 - A
10 - B
Copia el código
10 - Un instituto de meteorología desea realizar un estudio de la temperatura media de cada mes del año. Para ello, debes crear un código que recoja y almacene esas temperaturas medias en una lista. Luego, calcula el promedio anual de las temperaturas y muestra todas las temperaturas por encima del promedio anual y en qué mes ocurrieron, mostrando los meses por su nombre (Enero, Febrero, etc.).

11 - Una empresa de comercio electrónico está interesada en analizar las ventas de sus productos. Los datos de ventas se han almacenado en un diccionario:

{'Producto A': 300, 'Producto B': 80, 'Producto C': 60, 'Producto D': 200, 'Producto E': 250, 'Producto F': 30}
Copia el código
Escribe un código que calcule el total de ventas y el producto más vendido.

12 - Se realizó una encuesta de mercado para decidir cuál diseño de marca infantil es más atractivo para los niños. Los votos de la encuesta se pueden ver a continuación:

Tabla de votos de la marca
Diseño 1 - 1334 votos
Diseño 2 - 982 votos
Diseño 3 - 1751 votos
Diseño 4 - 210 votos
Diseño 5 - 1811 votos
Copia el código
Adapta los datos proporcionados a una estructura de diccionario. A partir de ello, informa el diseño ganador y el porcentaje de votos recibidos.

13 - Los empleados de un departamento de tu empresa recibirán una bonificación del 10% de su salario debido a un excelente rendimiento del equipo. El departamento de finanzas ha solicitado tu ayuda para verificar las consecuencias financieras de esta bonificación en los recursos. Se te ha enviado una lista con los salarios que recibirán la bonificación: [1172, 1644, 2617, 5130, 5532, 6341, 6650, 7238, 7685, 7782, 7903]. La bonificación de cada empleado no puede ser inferior a 200. En el código, convierte cada uno de los salarios en claves de un diccionario y la bonificación de cada salario en el valor correspondiente. Luego, informa el gasto total en bonificaciones, cuántos empleados recibieron la bonificación mínima y cuál fue el valor más alto de la bonificación proporcionada.

14 - Un equipo de científicos de datos está estudiando la diversidad biológica en un bosque. El equipo recopiló información sobre el número de especies de plantas y animales en cada área del bosque y almacenó estos datos en un diccionario. En él, la clave describe el área de los datos y los valores en las listas corresponden a las especies de plantas y animales en esas áreas, respectivamente.

{'Área Norte': [2819, 7236], 'Área Leste': [1440, 9492], 'Área Sul': [5969, 7496], 'Área Oeste': [14446, 49688], 'Área Centro': [22558, 45148]}
Copia el código
Escribe un código para calcular el promedio de especies por área e identificar el área con la mayor diversidad biológica. Sugerencia: utiliza las funciones incorporadas sum() y len().

15 - El departamento de Recursos Humanos de tu empresa te pidió ayuda para analizar las edades de los colaboradores de 4 sectores de la empresa. Para ello, te proporcionaron los siguientes datos:

{'Setor A': [22, 26, 30, 30, 35, 38, 40, 56, 57, 65],
 'Setor B': [22, 24, 26, 33, 41, 49, 50, 54, 60, 64],
 'Setor C': [23, 26, 26, 29, 34, 35, 36, 41, 52, 56],
 'Setor D': [19, 20, 25, 27, 34, 39, 42, 44, 50, 65]}
Copia el código
Dado que cada sector tiene 10 colaboradores, construye un código que calcule la media de edad de cada sector, la edad media general entre todos los sectores y cuántas personas están por encima de la edad media general.

Si necesitas ayuda, las soluciones a las actividades están disponibles en la sección "Opinión del instructor".

Ver opinión del instructor
Opinión del instructor

Pueden existir diversas formas de resolver los problemas propuestos y algunas de ellas se presentan a continuación.

Calentando motores en la programación

1 - Incluso si ya sabemos manualmente cuál es el resultado, es interesante pensar cómo podríamos ejecutar las operaciones mediante programación.

# Datos de gastos
gastos = [2172.54, 3701.35, 3518.09, 3456.61, 3249.38, 2840.82, 3891.45, 3075.26, 2317.64, 3219.08]

# Calculamos el promedio encontrando el valor total de gastos con la función sum
# y la cantidad total de compras realizadas con len
total_gastos = sum(gastos)
cantidad_compras = len(gastos)
media_gastos = total_gastos / cantidad_compras
# Resultado
print(f'El promedio de gastos es {media_gastos} reales.')
Copia el código
2 -

# Datos de gastos
gastos = [2172.54, 3701.35, 3518.09, 3456.61, 3249.38, 2840.82, 3891.45, 3075.26, 2317.64, 3219.08]

# Variable que contará cuántas compras se realizaron por encima de 3000
contador_acima_3000 = 0
# Usamos un bucle para recorrer la lista de gastos
for gasto in gastos:
  # Verificamos si el elemento está por encima de 3000
  if gasto > 3000:
    # Sumamos uno al contador si hay algún valor por encima de 3000
    contador_acima_3000 += 1

# Con el conteo podemos calcular el porcentaje de valores por encima de 3000 entre todas las compras
porcentaje_acima_3000 = 100 * contador_acima_3000 / cantidad_compras

# Resultado
print(f'{contador_acima_3000} compras estuvieron por encima de R$3000,00.')
print(f'{porcentaje_acima_3000}% de los gastos estuvieron por encima de R$3000,00.')
Copia el código
3 -

# Lista que almacenará los 5 números enteros
lista_numeros = []

# Creamos un bucle que iterará 5 veces para recibir los 5 números
for i in range(0, 5):
  # Recopilamos el valor e lo insertamos en la lista 5 veces
  numero = int(input('Ingresa un número entero: '))
  lista_numeros.append(numero)
#Resultado
print(f'Lista de números ingresados: {lista_numeros}')
Copia el código
4 - Dado que el objetivo es imprimir la lista de números enteros en orden inverso al ingresado, podemos utilizar la técnica de partición, en la que la lista se recorre desde el último elemento (usando el índice -1) hasta el primero. De esta manera, la lista se imprime en orden inverso al original, de modo que el último elemento es el primero en mostrarse, seguido por el penúltimo elemento y así sucesivamente.

# Lista que almacenará los 5 números enteros
lista_numeros = []

# Creamos un bucle que iterará 5 veces para recibir los 5 números
for i in range(0, 5):
  # Recopilamos el valor e lo insertamos en la lista 5 veces
  numero = int(input('Ingresa un número entero: '))
  lista_numeros.append(numero)
# Usamos la técnica de partición para imprimir el resultado
print(f'Lista de números invertida: {lista_numeros[::-1]}')
Copia el código
5 - Para este problema, necesitamos verificar si todos los números, por debajo de lo especificado por el usuario, son o no divisibles por otros valores además de sí mismos. Para hacer esto, podemos anidar un bucle dentro de otro. Usamos un bucle para recorrer los números enteros de 2 al número ingresado. Para cada número, otro bucle se utiliza para verificar si es divisible por números más pequeños que él. Si el número no es divisible por ninguno de estos números, se considera un número primo. Esta estructura se puede observar a continuación:

# Recopilamos el número
numero = int(input('Ingresa un número entero: '))
# Lista para almacenar los números primos
lista_primos = []
# Bucle que recorre todos los números por debajo del número ingresado
for num in range(2, numero):
  # Primo es una bandera que nos permite saber si el valor analizado es primo o no.
  primo = True
  # Probamos si todos los números por debajo del especificado en el primer bucle pueden dar una división exacta.
  for prueba_divisibles in range(2, num):
    if num % prueba_divisibles == 0:
      # Si es divisible por algún número, entendemos que el número no es primo y terminamos el bucle interno con break.
      primo = False
      break
  # La condición se convierte en el resultado booleano de primo: False. Ignoramos la condición True y ejecutamos el bloque del if.
  if primo:
    lista_primos.append(num)
# Resultado
print(f'Lista de números primos: {lista_primos}')
Copia el código
6 - Recopilamos el día, mes y año de una fecha y realizamos comprobaciones mes a mes, confirmando si en febrero (sea o no un año bisiesto) el día coincide con lo que es posible. También se analizan los meses que terminan en 31 o 30 días para evitar la existencia de fechas inválidas en los datos.

# Recopilamos la fecha
dia = int(input('Ingrese el día: '))
mes = int(input('Ingrese el mes: '))
año = int(input('Ingrese el año: '))

# Análisis de febrero
if mes == 2:
  # Verificamos si es o no un año bisiesto
  if año % 4 == 0 and (año % 400 == 0 or año % 100 != 0):
    dias_febrero = 29
  else:
    dias_febrero = 28
  # Verificamos si el día ingresado coincide con el máximo de días de febrero
  if dia >= 1 and dia <= dias_febrero:
    print('Fecha válida')
  else:
    print('Fecha inválida')
# Verificamos meses que terminan en 31 días
elif mes in [1, 3, 5, 7, 8, 10, 12]:
  if dia >= 1 and dia <= 31:
    print('Fecha válida')
  else:
    print('Fecha inválida')
# Verificamos meses que terminan en 30 días
elif mes in [4, 6, 9, 11]:
  if dia >= 1 and dia <= 30:
    print('Fecha válida')
  else:
    print('Fecha inválida')
# Si el mes no está entre 1 y 12
else:
  print('Fecha inválida')
Copia el código
7 -

# Lista de crecimiento de bacterias
bacterias_colonia = [1.2, 2.1, 3.3, 5.0, 7.8, 11.3, 16.6, 25.1, 37.8, 56.9]
# Lista que almacenará las tasas de crecimiento
porcentaje_crecimiento = []
# Recorremos los índices de 1 a 9 para comparar los valores actuales con los anteriores
for i in range(1, len(bacterias_colonia)):
  # Realizamos el cálculo: 100 * (muestra_actual - muestra_anterior) / (muestra_anterior)
  porcentaje = 100 * (bacterias_colonia[i] - bacterias_colonia[i-1]) / (bacterias_colonia[i-1])
  # Agregamos el resultado a la lista porcentaje_crecimiento
  porcentaje_crecimiento.append(porcentaje)
# Resultado
print(f'Porcentajes de crecimiento:\n{porcentaje_crecimiento}')
Copia el código
8 -

# Lista que contendrá los valores de IDs
ids = []
# Variables contadoras de dulces y amargos
dulce = 0
amargo = 0

# Creamos un bucle que iterará 10 veces para recopilar los 10 IDs
for i in range(0,10):
  # Recopilamos el ID y lo agregamos a la lista
  ids.append(int(input(f'Ingrese el ID {i+1}°: '))

# Leemos todos los elementos de la lista de IDs y los asignamos a id
for id in ids:
  # Verificamos si los elementos son pares o impares para llevar el conteo
  if id % 2 == 0:
    dulce += 1
  else:
    amargo += 1

# Resultado
print(f'Cantidad de productos dulces: {dulce}')
print(f'Cantidad de productos amargos: {amargo}')
Copia el código
9 -

# Inicializamos los datos
respuestas = []  # Lista para almacenar las respuestas
# Lista de respuestas correctas
gabarito = ['D', 'A', 'C', 'B', 'A', 'D', 'C', 'C', 'A', 'B']
nota = 0  # Acumulará la nota total

# Recopilamos las respuestas del estudiante
for i in range(0, 10):
  respuestas.append(input(f'Introduzca la respuesta a la pregunta {i + 1}: ').upper())

# Verificamos si las respuestas coinciden y las sumamos a la nota
for i in range(0, 10):
  if respuestas[i] == gabarito[i]:
    nota += 1

# Mostrando la nota final
print(f'Nota final: {nota}')
Copia el código
10 -

# Recopilamos la lista de temperaturas mensuales
temperaturas_mensuales = []
for i in range(0, 12):
  temperaturas_mensuales.append(float(input(f'Ingrese la temperatura promedio del mes {i+1}: '))
# Creamos una lista auxiliar para los nombres de los meses
meses = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre']
# Calculamos el promedio
media_anual = sum(temperaturas_mensuales) / len(temperaturas_mensuales)

# Resultado
print('Temperaturas por encima del promedio en: ')
for i in range(0, 12):
  # Verificamos todas las temperaturas en comparación con la media anual
  if temperaturas_mensuales[i] > media_anual:
    # Dado que los índices de los meses corresponden a las temperaturas,
    # podemos imprimirlos con el mismo índice
    print(meses[i])
Copia el código
11 -

# Diccionario de ventas
datos_ventas = {'Producto A': 300, 'Producto B': 80, 'Producto C': 60, 'Producto D': 200, 'Producto E': 250, 'Producto F': 30}

# Inicializamos las variables
total_ventas = 0  # Sumará todas las ventas
producto_mas_vendido = ''  # Almacenará el nombre del producto más vendido
unidades_producto_mas_vendido = 0  # Almacenará la cantidad más alta de ventas

# Recorremos las claves y elementos del diccionario
for producto in datos_ventas.keys():
    # Sumamos el total de ventas
    total_ventas += datos_ventas[producto]
    # Verificamos si el valor de ventas actual (datos_ventas[producto]) es mayor que el valor almacenado en unidades_producto_mas_vendido
    # Cada vez que datos_ventas[producto] supere el valor en unidades_producto_mas_vendido,
    # la variable unidades_producto_mas_vendido será igual a datos_ventas[producto], asignando un nuevo valor
    # De manera similar, producto_mas_vendido también se actualiza con el producto actual
    if datos_ventas[producto] > unidades_producto_mas_vendido:
        unidades_producto_mas_vendido = datos_ventas[producto]
        producto_mas_vendido = producto
# Resultados
print(f'Total de ventas es {total_ventas}')
print(f'{producto_mas_vendido} es el más vendido')
Copia el código
12 -

# Diccionario de votos por diseño
votos = {'Diseño 1': 1334, 'Diseño 2': 982, 'Diseño 3': 1751, 'Diseño 4': 210, 'Diseño 5': 1811}

# Inicializamos las variables
total_votos = 0  # Sumará todos los votos
ganador = ''  # Almacenará el nombre del diseño ganador
voto_ganador = 0  # Almacenará la cantidad ganadora de votos

# Recorremos las claves y elementos del diccionario
for diseño, voto_diseño in votos.items():
    # Sumamos el total de votos
    total_votos += voto_diseño
    # Verificamos si el voto del diseño actual (voto_diseño) es mayor que el valor almacenado en voto_ganador
    # Cada vez que voto_diseño supere el valor en voto_ganador,
    # la variable voto_ganador será igual a voto_diseño, asignando un nuevo valor
    # De manera similar, el ganador también se actualiza con el diseño actual
    if voto_diseño > voto_ganador:
        voto_ganador = voto_diseño
        ganador = diseño
# Calculamos el porcentaje del diseño ganador
porcentaje = 100 * (voto_ganador) / (total_votos)

# Resultado
print(f'{ganador} es el ganador: ')
print(f'Porcentaje de votos: {porcentaje}%')
Copia el código
13 -

# Lista de salarios
salarios = [1172, 1644, 2617, 5130, 5532, 6341, 6650, 7238, 7685, 7782, 7903]
# Inicializamos las variables
diccionario_abonos = {}  # Diccionario de abonos
total_abono = 0  # Sumará todos los gastos en abonos
abonos_minimo = 0  # Almacenará la cantidad de abonos mínimos
mayor_abono = 0  # Almacenará el mayor valor de abono

# Recorremos toda la lista de salarios
for salario in salarios:
    # Calculamos el valor teórico del abono
    abono = salario * 0.1
    # Si el abono es inferior a 200,
    # ajustamos el valor del abono al mínimo (200)
    if abono < 200:
        abono = 200
    # Agregamos un nuevo dato en el diccionario con la clave abono
    diccionario_abonos[salario] = abono

# Recorremos todos los valores del diccionario de abonos
for abono in diccionario_abonos.values():
    # Contamos los salarios mínimos
    if abono == 200:
        abonos_minimo += 1
    # Verificamos si el abono leído es mayor que el valor almacenado en mayor_abono
    # Cada vez que el abono supere el valor de mayor_abono,
    # la variable mayor_abono será igual al abono, asignando un nuevo valor
    if abono > mayor_abono:
        mayor_abono = abono
    # Sumamos los abonos
    total_abono += abono
# Resultados
print(f'Abonos: {diccionario_abonos}')
print(f'Total de gastos en abonos: {total_abono}')
print(f'Número de empleados que recibieron el abono mínimo: {abonos_minimo}')
print(f'Mayor valor de abono: {mayor_abono}')
Copia el código
14 -

# Especificamos los datos para un diccionario
datos = {'Área Norte': [2819, 7236],
         'Área Este': [1440, 9492],
         'Área Sur': [5969, 7496],
         'Área Oeste': [14446, 49688],
         'Área Centro': [22558, 45148]}
# Inicializamos las variables
suma_media = 0  # Sumará todos los promedios
mayor_diversidad = ''  # Almacenará el área con la mayor diversidad
mayor_suma = 0  # Almacenará la mayor suma de especies
# Recorremos las claves y elementos del diccionario
for área, especies in datos.items():
    # Sumamos el número de especies en cada área utilizando la función sum
    suma_especies = sum(especies)
    # Calculamos el promedio dividiendo la suma de las especies entre la cantidad de especies
    media = suma_especies / len(especies)
    # Imprimimos
    print(f'El {área} tiene un promedio de {media} especies')
    # Verificamos si la suma de especies es mayor que el valor almacenado de mayor_suma
    # Cada vez que suma_especies supere el valor de mayor_suma,
    # la variable mayor_suma será igual a suma_especies, asignando un nuevo valor
    # De manera similar, mayor_diversidad también se actualiza
    if suma_especies > mayor_suma:
        mayor_suma = suma_especies
        mayor_diversidad = área
    # Sumamos los promedios
    suma_media += media
# La media total será la suma_media dividida por la cantidad de áreas
media_total = suma_media / len(datos)
print(f'Media general de especies: {media_total}')
print(f'Área con la mayor diversidad biológica: {mayor_diversidad}')
Copia el código
15 -

# Especificamos los datos para un diccionario
datos = {'Sector A': [22, 26, 30, 30, 35, 38, 40, 56, 57, 65],
        'Sector B': [22, 24, 26, 33, 41, 49, 50, 54, 60, 64],
        'Sector C': [23, 26, 26, 29, 34, 35, 36, 41, 52, 56],
        'Sector D': [19, 20, 25, 27, 34, 39, 42, 44, 50, 65]}
# Inicializamos la variable que sumará todas las edades
total_edades = 0
# Recorremos las claves y elementos del diccionario
for sector, edades in datos.items():
  # Calculamos el promedio dividiendo la suma de las edades entre la cantidad de empleados en cada sector
  media_edad = sum(edades) / len(edades)
  # Imprimimos
  print(f'El {sector} tiene un promedio de {media_edad}')
  # Sumamos los promedios
  total_edades += sum(edades)
# La media total será el total_edades dividido por la cantidad de personas totales (sectores * empleados por sector)
media_total = total_edades / (len(edades) * len(datos))
print(f'La media de edad general es {media_total}')

# Inicializamos la variable que contará a todas las personas con edades por encima de la media
arriba_media = 0
# Recorremos nuevamente las claves y elementos del diccionario
for sector, edades in datos.items():
  # Leemos los elementos (edades) dentro de cada lista de edades en el diccionario
  for edad in edades:
    # Verificamos si el valor de la edad es superior a la media total
    if edad > media_total:
      # En caso de que el valor de la edad sea superior a la media, incrementamos en uno el contador
      arriba_media += 1
# Resultado
print(f'{arriba_media} personas están por encima de la edad media general')
Copia el código
Ejercitar es importante para afianzar el contenido, desarrollar habilidades de codificación, identificar áreas que aún no se han comprendido, prepararse para desafíos futuros y desarrollar el pensamiento lógico y la resolución de problemas.

Por lo tanto, es importante realizar muchos ejercicios cuando se está aprendiendo un nuevo lenguaje de programación. Así que busca practicar a través de los ejercicios propuestos y observa cómo esto puede ayudarte a mejorar tus habilidades de codificación.

Si tienes alguna pregunta, utiliza el foro o nuestra comunidad en Discord.
***********************************************************************************************************+
 13 Proyecto final
 Siguiente pregunta

Aquí puedes descargar los archivos del proyecto completo.

https://github.com/alura-es-cursos/python-para-datascience-primeros-pasos/blob/proyecto-final/Python_Data_Science.ipynb

***********************************************************************************************************************+
14 Lo que aprendimos
 Siguiente pregunta

Lo que aprendimos en esta aula:

Construir estructuras de datos.
Crear listas y diccionarios.
Llenar y manipular listas y diccionarios.
**************************************************************************************************************************
*******************************************************************************************************************+
0.3 Estructuras de datos
01 Proyecto del aula anterior
 Siguiente pregunta

¿Comenzando en esta etapa? Aquí puedes descargar los archivos del proyecto que hemos avanzado hasta el aula anterior.

Descargue los archivos en Github o haga clic aquí para descargarlos directamente.
************************************************************************************************************
02 Lista de listas
En esta clase, aprendimos sobre estructuras de datos compuestas, específicamente sobre las listas de listas en Python. Comenzamos revisando cómo trabajar con listas anidadas, que son listas que contienen otras listas como elementos.

Se presentó un ejemplo práctico donde se tenía una lista llamada Notas_Grupo, que contenía los nombres de estudiantes y sus calificaciones de tres trimestres. El objetivo era separar los nombres de las calificaciones y organizarlas en una lista de listas.

Primero, creamos dos listas vacías: Nombres para almacenar los nombres de los estudiantes y Notas para las calificaciones. Utilizamos un bucle para iterar sobre los elementos de Notas_Grupo, aplicando la función mod para identificar los nombres y las calificaciones.

Luego, se realizó otra iteración para agrupar las calificaciones en una lista de listas llamada Notas_Separadas, donde cada sublista contenía las tres calificaciones de cada estudiante.

Finalmente, se mostró cómo resolver problemas que surgen durante el proceso y se mencionó que en la próxima clase se abordará otro tipo de estructura anidada: la lista de tuplas.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
03 Importancia de las listas de listas
 Siguiente pregunta

Avanzando en los estudios de Python, nos encontramos con la necesidad de crear estructuras más robustas y complejas para almacenar datos de diversos tipos y analizarlos utilizando técnicas de exploración de datos. Es bastante común en el día a día del científico de datos trabajar con estructuras de datos anidadas, como las listas de listas.

Dicho esto, ¿cuáles de las siguientes opciones señalan la importancia de trabajar con listas de listas en un proyecto de ciencia de datos en Python?

Alternativa correta
La importancia de las listas de listas radica en la facilidad de manipulación de datos de diferentes tipos, separados en listas dentro de la estructura.


Pueden utilizarse para almacenar datos de diferentes tipos y formatos, haciendo que el código sea más flexible y adaptable a diferentes escenarios de análisis de datos.

Alternativa correta
Las listas de listas son importantes porque posibilitan el almacenamiento organizado de información, como en tablas y matrices.


Esta es una de las razones por las que las listas de listas se utilizan ampliamente en ciencia de datos. Al dividir los datos de manera organizada y similar al formato matricial, la recopilación y análisis de datos puede aplicarse siguiendo patrones de lectura de datos.

Alternativa correta
Las listas de listas son importantes porque permiten agrupar datos de manera segura y garantizan que los datos no se modifiquen accidentalmente.


Alternativa correta
Las listas de listas son importantes porque permiten almacenar datos en una estructura jerárquica.


Permiten almacenar datos en una estructura jerárquica, lo cual puede ser útil en muchas situaciones en las que los datos tienen varias dimensiones.

¡Enhorabuena, has acertado!
 Discutir en el Foro
 Siguiente 
*****************************************************************************************+
04 Lista de tuplas
En esta clase, se abordó el tema de las estructuras de datos, específicamente la creación de una lista de tuplas en Python. Se explicó que una lista es una secuencia mutable de objetos, mientras que una tupla es inmutable.

Se presentó un ejercicio donde se necesitaba generar una lista de tuplas que contuvieran los nombres de estudiantes y un código ID único para cada uno. Este código se forma concatenando la primera letra del nombre del estudiante con un número aleatorio entre 0 y 999, utilizando la función RANDINT de la biblioteca Random.

Se definió una función llamada GENERANUMERO que retorna un número entero aleatorio, y se creó una lista vacía llamada CODIGOS_ESTUDIANTES. Luego, se utilizó un bucle FOR para iterar sobre los nombres de los estudiantes, generando y añadiendo tuplas a la lista con el nombre y el código generado.

Finalmente, se mencionó que en la próxima clase se explorará una forma más sencilla de realizar este proceso sin necesidad de crear una lista vacía y usar un bucle FOR.
************************************************************************************************
05 Para saber más: trabajando con tuplas
 Siguiente pregunta

Las tuplas son estructuras de datos inmutables en el lenguaje Python que se utilizan para almacenar conjuntos de múltiples elementos y a menudo se aplican para agrupar datos que no deben modificarse. Es decir, no es posible agregar, cambiar o eliminar sus elementos después de creadas. Vamos a explorar un poco más este tipo de estructura enfocada en la aplicación en ciencia de datos.

Las tuplas son especialmente útiles en situaciones en las que necesitamos garantizar que los datos no se modifiquen accidental o intencionalmente. Por ejemplo, en un conjunto de datos que representa el registro de estudiantes, podemos utilizar una tupla para representar a ese estudiante en particular y mantenerlo en la base de datos de una institución educativa. De esta manera, aseguramos que la información de cada estudiante no se modifique inadvertidamente.

Para crear una tupla, simplemente separamos sus elementos por comas y los envolvemos entre paréntesis. Por ejemplo, podemos crear una tupla con un registro de una estudiante de la siguiente manera:

registro = ("Julia", 23, "CDMX", "EM", "Python para DS 1")
Copia el código
Para acceder a los elementos de una tupla, podemos usar el índice entre corchetes. Por ejemplo:

print(registro[0])  # imprime Julia
print(registro[-1])  # imprime Python para DS 1
Copia el código
Además, al ser un iterable, podemos desempaquetar los datos de una tupla pasando cada valor a una variable. Por ejemplo:

nombre, edad, ciudad, estado, curso = registro
Copia el código
Y mostrar los datos del registro de la estudiante:

print(f'La estudiante {nombre} tiene {edad} años y vive en {ciudad}-{estado}. Ella está matriculada en el curso de {curso}.')
Copia el código
Salida:

La estudiante Julia tiene 23 años y vive en CDMX-EM. Ella está matriculada en el curso de Py
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 06 Uso de la lista de tuplas
 Siguiente pregunta

Otra estructura de datos compuesta y ampliamente utilizada en el contexto de la ciencia de datos son las listas de tuplas. A diferencia de las listas de listas, se indican en situaciones en las que necesitamos garantizar que los datos no se alteren accidental o intencionalmente, pero que puedan accederse para agregar más datos en los análisis.

Dicho esto, ¿cuál de las siguientes opciones representa un uso adecuado de la estructura de listas de tuplas?

Alternativa correta
Un ejemplo de listas de tuplas puede ser un conjunto de datos que contenga información sobre películas, incluyendo el título, año de lanzamiento y género. Por ejemplo:

peliculas = [ ('El Padrino', 1972,'Drama'), ('El Señor de los Anillos: El Retorno del Rey', 2003, 'Aventura'), ('Interestelar', 2014, 'Ciencia ficción')]


Este ejemplo representa un uso adecuado de listas de tuplas, ya que los datos sobre las películas no necesitan actualizarse una vez creados, y la lista puede ampliarse con nuevas tuplas.

Alternativa correta
Un ejemplo de listas de tuplas puede ser la de una lista de museos y los valores de entrada para cada uno de ellos. Por ejemplo:

museos = [('Museo de Arte', 20), ('Museo Bicentenario', 10), ('Museo de la Música', 25)]


Alternativa correta
Un ejemplo de listas de tuplas puede ser la de una lista de asistencia de una institución educativa que se completa mediante un formulario. Por ejemplo:

lista_presencia = [(1, 'Maria Clara'), (2, 'Antonio Costa'), (3, 'Joanna Diaz'), (4, 'Marcelo Sosa')]


Este ejemplo representa un uso adecuado de listas de tuplas, ya que la lista de asistencia puede ampliarse con nuevos registros a medida que se completen más formularios.

Alternativa correta
Un ejemplo de listas de tuplas puede ser la de platos de un restaurante y sus ventas que se están realizando este mes. Por ejemplo:

platos = [('Pollo parmigiana', 100),('Strogonoff de carne', 150),('Bife a parmigiana', 75),('Ensalada Caesar', 120)]
************************************************************************************************************************
07 Lo que aprendimos
 Siguiente pregunta

Lo que aprendimos en esta aula:

Crear listas de listas y listas de tuplas.
Acceder y extraer listas y elementos de una lista de listas.
***************************************************************************************************
0.4 Estructuras anidadas
01 Proyecto del aula anterior (c4)
*********************************************************
02
List Comprehension
En esta clase, se abordó el concepto de comprensión de listas en Python, una técnica que permite crear listas de manera concisa y legible. Se explicó cómo utilizar esta herramienta para calcular el promedio de calificaciones de estudiantes a partir de una lista de listas.

Se presentó un ejemplo práctico donde se creó una lista de promedios redondeados a un decimal utilizando la función round. Luego, se mostró cómo agrupar estos promedios con los nombres de los estudiantes, utilizando la función zip para combinar listas de nombres y promedios en tuplas.

Finalmente, se explicó cómo filtrar a los estudiantes que tienen un promedio mayor o igual a 8 para que puedan competir por una beca de estudios, utilizando nuevamente la comprensión de listas con una condición if. Se destacó la legibilidad y la simplicidad que ofrece la comprensión de listas en comparación con otros métodos de creación de listas.
*****************************************************************
03 Para saber más: función zip()
 Siguiente pregunta

La función zip() es una función incorporada de Python que toma uno o más iterables (lista, cadena, diccionario, etc.) y los devuelve como un iterador de tuplas donde cada elemento de los iterables está emparejado. Es útil para realizar iteraciones simultáneas en varias listas.

La función zip() se puede utilizar junto con otras funciones de Python, como map() y filter(), para crear soluciones elegantes y concisas para ciertos problemas. Realicemos una prueba simple para verificar este comportamiento:

objeto_zip = zip([1, 2, 3])
objeto_zip
Copia el código
Salida:

<zip at 0x7f28fc5c0040>
Copia el código
Notamos que zip() creó un objeto zip en la memoria, que sería nuestro iterable. Coloquemos el resultado en una lista para verificar la salida:

list(objeto_zip)
Copia el código
Salida:

[(1,), (2,), (3,)]
Copia el código
Observa que, con solo un iterable, se generó una lista de tuplas, donde cada tupla tiene, como uno de los pares, los elementos provenientes de la lista [1, 2, 3] y la otra parte de los pares está vacía. Como solo usamos un iterable, cada tupla está vacía en el segundo elemento, ya que zip() actúa para crear pares de iterables.

Pero lo más interesante es trabajar con dos o más iterables en los que podemos emparejarlos. Por ejemplo, si queremos crear una lista de tuplas con la asignación de las regiones de Brasil con sus respectivos identificadores:

id = [1, 2, 3, 4, 5]
region = ["Norte", "Oriente", "Sudeste", "Centro", "Sur"]

mapa = list(zip(id, region))
mapa
Copia el código
Salida:

[(1, 'Norte'), (2, Oriente), (3, 'Sudeste'), (4, 'Centro'), (5, 'Sur')]
Copia el código
Para un científico de datos, esta función puede ayudar a emparejar dos listas diferentes en un único objeto zip, que se puede transformar en una lista de tuplas (formato ideal para generar un índice de más de un nivel que se explorará en algunos de los cursos de la formación) o en un diccionario pasando el objeto zip a la función dict().

Ahora, si las listas de entrada tienen longitudes diferentes, la salida contendrá el mismo número de tuplas que la lista de menor longitud y los elementos restantes de los otros iterables se ignorarán. Por ejemplo:

codigos = ["1000", "1001", "1002", "1003", "1004", "1005"]
frutas = ["manzana", "uva", "banana", "naranja"]

mercancia = list(zip(codigos, frutas))
mercancia
Copia el código
Salida:

[('1000', 'manzana'), ('1001', 'uva'), ('1002', 'banana'), ('1003', 'naranja')]
Copia el código
Para realizar el proceso contrario, de transformar una tupla iterable en listas, basta con colocar el operador asterisco (*) al lado izquierdo del nombre de la tupla iterable que se desea extraer los datos, transmitiendo cada tupla a una variable.

tupla_iterable = [('J392', 'Juan'), ('M890', 'Maria'), ('J681', 'José'), ('C325', 'Claudia'), ('A49', 'Ana')]
ids, nombres = zip(*tupla_iterable)

ids = list(ids)
nombres = list(nombres)

print("IDs = ", ids)
print("Nombres = ", nombres)
Copia el código
Salida:

IDs = ['J392', 'M890', 'J681', 'C325', 'A49']
Nombres = ['Juan', 'Maria', 'José', 'Claudia', 'Ana']
Copia el código
La idea de realizar un "desempaquetado inverso" es útil cuando queremos extraer claves o valores por separado o generar una lista de tuplas separadas, con el conjunto de claves y valores, cada uno representado en una tupla.
****************************************************************************************
04 List Comprehension con if y else ~ VER
En esta clase, aprendimos sobre estructuras anidadas en Python, específicamente cómo utilizar la comprensión de listas con condiciones if y else. Se nos presentó un proyecto relacionado con las notas de los estudiantes, donde debíamos crear una lista llamada situación que indicara si cada estudiante fue "aprobado" o "reprobado" según su promedio. Si el promedio era mayor o igual a 7, el estudiante era considerado aprobado; de lo contrario, reprobado.

Además, se generó una lista de listas llamada registros, que contenía los nombres de los estudiantes, sus notas, promedios y situaciones. Se mostró cómo crear esta lista de manera sencilla, utilizando corchetes para incluir directamente las listas necesarias sin necesidad de iteraciones complejas.

Finalmente, se mencionó que los códigos de los estudiantes pueden variar en cada ejecución debido a la generación de números aleatorios, lo cual es normal. En la próxima clase, se abordará un tema relacionado: la comprensión de diccionarios.
////////////////////////////////////////////////////////////////////////////////////////////////////
05 ¿Qué hace el siguiente código?
 Siguiente pregunta

Andrés recibió una solicitud para analizar el conjunto de datos que contiene información sobre la altura y el peso de varias personas. Para procesar estos datos, André utilizó la estructura de list comprehension para calcular y también guardar los datos del Índice de Masa Corporal (IMC). Vea el código desarrollado por él a continuación:

alturas = [1.70, 1.80, 1.65, 1.75, 1.90]
pesos = [65, 80, 58, 70, 95]

imc = [round((peso / altura**2), 1) for altura, peso in zip(alturas, pesos)]
print(imc)
Copia el código
A partir de la lectura del código creado por Andrés, ¿cuál es el resultado presentado en la salida del terminal?

Alternativa correta
El código anterior genera una lista de listas con las alturas, pesos e IMC de cada persona en el conjunto de datos.


Alternativa correta
El código anterior genera una lista de tuplas con alturas, pesos e IMC de cada persona en el conjunto de datos.


Alternativa correta
El código anterior genera una lista con los IMCs de cada persona en el conjunto de datos.


En este ejemplo, el list comprehension se utiliza para leer cada uno de los valores de las listas de altura y peso que se emparejaron con zip(), y se calcula el IMC redondeado a una décima.
************************************************************************************************************
06 Dict Comprehension
En esta clase, se abordó el concepto de comprensión de diccionarios en Python, que es similar a la comprensión de listas. Se explicó cómo crear un diccionario a partir de una lista de listas, donde las claves del diccionario representan las columnas de datos y los valores son las listas correspondientes a cada clave.

Se presentó un ejercicio en el que se debía generar un diccionario llamado registro, que incluiría las notas, el promedio final y la situación de los estudiantes. Para ello, se utilizó una lista llamada lista_completa y se definieron las columnas necesarias. Se mostró cómo iterar sobre los elementos de lista_completa para extraer los datos y organizarlos en el diccionario.

Finalmente, se mencionó que en la próxima clase se tratará el manejo de errores en el código, un tema importante para evitar interrupciones en el desarrollo del programa.
////////////////////////////////////////////////////////////////////////////////////////////////////////////
07 Seleccionando a los becados
 Siguiente pregunta

Recibimos una demanda de la institución educativa de nuestro proyecto que nos proporcionó una lista de 20 estudiantes y sus respectivos promedios finales. Aquí, necesitamos seleccionar estudiantes que tengan un promedio final mayor o igual a 9.0. Estos estudiantes serán premiados con una beca de estudios para el próximo año escolar.

Para filtrar los datos, debemos generar un diccionario cuyas claves son los nombres y los valores son los promedios de los estudiantes seleccionados. Estos son los datos recibidos:

nombres_estudiantes = ["Enrique Montero", "Luna Pereira", "Anthony Silva", "Leticia Fernandez", "Juan González", "Maira Caldera", "Diana Carvajo", "Mariana Rosas", "Camila Fernandez", "Levi Alves", "Nicolás Rocha", "Amanda Navas",  "Lara Morales", "Leticia Olivera", "Lucas Navas", "Lara Arteaga", "Beatriz Martinez", "Victor Acevedo", "Stephany Hernández", "Gustavo Lima"]

medias_estudiantes = [5.4, 4.1, 9.1, 5.3, 6.9, 3.1, 9.0, 5.0, 8.2, 5.5,
                    8.1, 7.4, 5.0, 3.7, 8.1, 6.2, 6.1, 5.6, 10.0, 8.2]
Copia el código
¿Cuál de los códigos a continuación representa la forma correcta de generar el diccionario con los estudiantes seleccionados?

Tip ⇒ Utiliza a forma:

{expresion_llave: expresion_valor for item in iterable if condicion}
Copia el código
Alternativa correta
becados = {nombre: media for nombre, media in zip(nombres_estudiantes, medias_estudiantes) if media >= 9.0}
becados

# Salida: {'Anthony Silva': 9.1, 'Stephany Hernández': 10.0}

Esta es una de las formas de generar el diccionario de estudiantes con un promedio superior a 9.0 teniendo en cuenta las listas proporcionadas. zip() aquí ayuda en la construcción de los pares de nombre y promedio de cada estudiante, y cada par se itera y filtra por la condición para construir la clave y el valor del diccionario.

Alternativa correta
becados = {nombres_estudiantes: media for media in medias_estudiantes if media >= 9.0}
becados

# Salida: {'Anthony Silva': 9.1, 'Stephany Hernández': 10.0}

Alternativa correta
becados = {nombres_estudiantes: medias_estudiantes for i in range(len(medias_estudiantes)) if medias_estudiantes[i] >= 9.0}
becados

# Salida: {'Anthony Silva': 9.1, 'Stephany Hernández': 10.0}

En este ejemplo, leemos la posición de los elementos del iterable de promedios. Pero pasamos a la clave y al valor la lista completa de nombres y promedios a la vez, lo que generará un error.

¡Enhorabuena, has acertado!
 Discutir en el Foro
 Siguiente pregunta
****************************************************************************************************************************	
08 Desafío: hora de practicar
 Siguiente pregunta

1 - Crea un código para imprimir la suma de los elementos de cada una de las listas contenidas en la siguiente lista:

lista_de_listas = [[4, 6, 5, 9], [1, 0, 7, 2], [3, 4, 1, 8]]
Copia el código
2 - Crea un código para generar una lista que almacene el tercer elemento de cada tupla contenida en la siguiente lista de tuplas:

lista_de_tuplas = [('Pedro', 1.74, 81), ('Júlia', 1.65, 67), ('Otávio', 1.81, 83)]
Copia el código
3 - A partir de la lista: lista = ['Pedro', 'Júlia', 'Otávio', 'Eduardo'], crea un código para generar una lista de tuplas en la que cada tupla tenga el primer elemento como la posición del nombre en la lista original y el segundo elemento siendo el propio nombre.

4 - Crea una lista usando la comprensión de listas (list comprehension) que almacene solo el valor numérico de cada tupla en caso de que el primer elemento sea 'Apartamento', a partir de la siguiente lista de tuplas:

alquiler = [('Apartamento', 1700), ('Apartamento', 1400), ('Casa', 2150), ('Apartamento', 1900), ('Casa', 1100)]
Copia el código
5 - Crea un diccionario usando la comprensión de diccionarios (dict comprehension) en el que las claves estén en la lista meses = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'] y los valores estén en gasto = [860, 490, 1010, 780, 900, 630, 590, 770, 620, 560, 840, 360].

6 - Una tienda tiene una base de datos con la información de venta de cada representante y de cada año y necesita filtrar solo los datos del año 2022 con ventas mayores a 6000. La tienda proporcionó una muestra con solo las columnas de los años y los valores de venta para que puedas ayudar a realizar la filtración de los datos a través de un código:

ventas = [('2023', 4093), ('2021', 4320), ('2021', 5959), ('2022', 8883), ('2023', 9859), ('2022', 5141), ('2022', 7688), ('2022', 9544), ('2023', 4794), ('2021', 7178), ('2022', 3030), ('2021', 7471), ('2022', 4226), ('2022', 8190), ('2021', 9680), ('2022', 5616)]
Copia el código
Crea una lista usando la comprensión de listas para filtrar los valores de 2022 que sean mayores a 6000.

7 - Una clínica analiza datos de pacientes y almacena el valor numérico de la glucosa en una base de datos y le gustaría etiquetar los datos de la siguiente manera:

Glucosa igual o inferior a 70: 'Hipoglicemia'
Glucosa entre 70 y 99: 'Normal'
Glucosa entre 100 y 125: 'Alterada'
Glucosa superior a 125: 'Diabetes'
La clínica proporcionó parte de los valores y tu tarea es crear una lista de tuplas usando la comprensión de listas que contenga la etiqueta y el valor de la glucemia en cada tupla.

glicemia = [129, 82, 60, 97, 101, 65, 62, 167, 87, 53, 58, 92, 66, 120, 109, 62, 86, 96, 103, 88, 155, 52, 89, 73]
Copia el código
8 - Un comercio electrónico tiene información de id de venta, cantidad vendida y precio del producto divididos en las siguientes listas:

id = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
cantidad = [15, 12, 1, 15, 2, 11, 2, 12, 2, 4]
precio = [93.0, 102.0, 18.0, 41.0, 122.0, 14.0, 71.0, 48.0, 14.0, 144.0]
Copia el código
La plataforma necesita estructurar estos datos en una tabla que contenga el valor total de la venta, que se obtiene multiplicando la cantidad por el precio unitario. Además, la tabla debe contener un encabezado indicando las columnas: 'id', 'cantidad', 'precio' y 'total'.

Crea una lista de tuplas en la que cada tupla tenga id, cantidad, precio y valor total, siendo la primera tupla el encabezado de la tabla.

9 - Una empresa tiene sucursales distribuidas en los estados de la región Sudeste de Brasil. En una de las tablas de registro de las sucursales, hay una columna que contiene la información de a qué estado pertenece: estados =['CMX', 'OAX', 'PUE', 'PUE', 'CMX', 'PUE', 'OAX', 'OAX', 'OAX', 'CMX', 'CMX', 'PUE', 'OAX', 'CMX', 'VER', 'PUE', 'VER', 'CMX', 'PUE', 'CMX', 'OAX', 'CMX', 'PUE'].

La empresa siempre está abriendo nuevas sucursales, por lo que la tabla está constantemente recibiendo nuevos registros y al gerente le gustaría tener la información actualizada de la cantidad de sucursales en cada estado.

A partir de la columna con la información de los estados, crea un diccionario utilizando la comprensión de diccionarios (dict comprehension) con la clave siendo el nombre de un estado y el valor siendo la cantidad de veces que aparece el estado en la lista.

Consejo: Puedes hacer un paso intermedio para generar una lista de listas en la que cada una de las listas tenga el nombre de solo un estado con valores repetidos.

10 - En esa misma tabla de registro de sucursales, hay una columna con la información de la cantidad de personas empleadas y el gerente quisiera tener un agrupamiento de la suma de esas personas para cada estado. Las informaciones contenidas en la tabla son:

 empleados = [('CMX', 16), ('OAX', 8), ('PUE', 9), ('PUE', 6), ('CMX', 10), ('PUE', 4), ('OAX',9),  ('OAX', 7), ('OAX', 12), ('CMX', 7), ('CMX', 11), ('PUE',8), ('OAX',8), ('CMX',9), ('VER', 13), ('PUE', 5),  ('VER', 9), ('CMX', 12), ('PUE', 10), ('CMX', 7), ('OAX', 14), ('CMX', 10), ('PUE', 12)]
Copia el código
A partir de la lista de tuplas, crea un diccionario en el que las claves son los nombres de los estados únicos y los valores son las listas con el número de empleados referentes al estado. También crea un diccionario en el que las claves son los nombres de los estados y los valores son la suma de empleados por estado.

 Discutir en el Foro
Ver opinión del instructor
ícone Python para Data Science: trabajar con funciones, estructuras de datos y excepciones
74%
Aula
04
de 05
Actividades
8 de 9
Discord Alura Foro del curso Volver al Dashboard
Modo claro
Gravatar de Sergio Luis Tolaba
40.8k xp

Logo da Alura Latam
Opinión del instructor

A continuación te presentamos las posibles soluciones al desafío propuesto:

1 -

for lista in lista_de_listas:
    print(sum(lista))
Copia el código
2 -

lista = []
for tupla in lista_de_tuplas:
    lista.append(tupla[2])
print(lista)
Copia el código
3 -

lista_de_tuplas = []
for i in range(len(lista)):
    lista_de_tuplas.append((i, lista[i]))
print(lista_de_tuplas)
Copia el código
4 -

lista = [tupla[1] for tupla in alquiler if tupla[0]== 'Apartamento']
print(lista)
Copia el código
5 -

diccionario = {meses[i]: gasto[i] for i in range(len(meses))}
print(diccionario)
Copia el código
6 -

filtro = [tupla[1] for tupla in ventas if tupla[0] == '2022' and tupla[1] > 6000]
print(filtro)
Copia el código
7 -

etiquetas = [('Hipoglicemia', glucosa) if glucosa<= 70 else ('Normal', glucosa) if glucosa< 100 else ('Alterada', glucosa) if glucosa< 125 else ('Diabetes', glucosa) for glucosa in glicemia]
print(etiquetas)
Copia el código
8 -

tabla = [('id', 'cantidad', 'precio', 'total')]
tabla += [(id[i], cantidad[i], precio[i], cantidad[i]*precoo[i]) for i in range(len(id))]
Copia el código
9 -

# Almacenando los estados sin repetición de valor
estados_unicos = list(set(estados))

# Creando una lista de listas con valores repetidos de cada estado
lista_de_listas = []
for estado in estados_unicos:
    lista = [e for e in estados if e == estado]
    lista_de_listas.append(lista)
print(lista_de_listas)

# Creando un diccionario en el que la clave es el nombre de cada estado único y el valor es la cantidad de elementos
conteo_valores = {estados_unicos[i]: len(lista_de_listas[i]) for i in range(len(estados_unicos))}
print(conteo_valores)
Copia el código
10 -

# Almacenando los estados sin repetición de valor
estados_unicos = list(set([tupla[0] for tupla in empleados]))

# Creando una lista de listas con valores de empleados de cada estado
lista_de_listas = []
for estado in estados_unicos:
    lista = [tupla[1] for tupla in empleados if tupla[0] == estado]
    lista_de_listas.append(lista)
print(lista_de_listas)

# Creando un diccionario con datos agrupados de empleados por estado
agrupamiento_por_estado = {estados_unicos[i]: lista_de_listas[i] for i in range(len(estados_unicos))}
print(agrupamiento_por_estado)

# Creando un diccionario con la suma de empleados por estado
suma_por_estado = {estados_unicos[i]: sum(lista_de_listas[i]) for i in range(len(estados_unicos))}
print(suma_por_estado)

**************************************************************************************************************
09 Lo que aprendimos
 Siguiente pregunta

Lo que aprendimos en esta aula:

Crear listas de diversas formas mediante la comprensión de listas (list comprehension).
Crear diccionarios mediante la comprensión de diccionarios (dict comprehension).
Trabajar con listas de listas en diccionarios.
Generar un nuevo registro clave/valor en un diccionario.
****************************************************************************************************
*************************************************************************************************
05. Trabajando con Excepciones
01 Proyecto del aula anterior
02 Tratando excepciones
¡Por supuesto! En esta clase, aprendimos sobre el manejo de excepciones en Python, que son errores que pueden ocurrir durante la ejecución de un programa. Es fundamental tratar estas excepciones para evitar que el programa se interrumpa de manera abrupta.

Los puntos clave que discutimos son:

Tipos de Errores: Existen errores de sintaxis y excepciones. Las excepciones son errores que se producen durante la ejecución y pueden ser manejadas.

Jerarquía de Excepciones: Python tiene una jerarquía de excepciones que nos ayuda a entender en qué orden pueden presentarse y cómo manejarlas.

Cláusulas TRY y EXCEPT: Utilizamos TRY para ejecutar un bloque de código que puede generar una excepción. Si ocurre una excepción, el flujo del programa se dirige al bloque EXCEPT, donde podemos manejar el error de manera controlada.

Ejemplo Práctico: Creamos un diccionario con las notas de los estudiantes y utilizamos TRY y EXCEPT para manejar el caso en que un estudiante no está matriculado, mostrando un mensaje amigable en lugar de un error técnico.

Uso de ELSE y FINALLY: Si no hay excepciones, podemos usar ELSE para ejecutar un bloque de código alternativo. Además, FINALLY nos permite ejecutar un bloque de código al final, independientemente de si ocurrió una excepción o no.

En resumen, el manejo de excepciones es una herramienta poderosa en Python que nos permite crear programas más robustos y amigables, evitando interrupciones inesperadas y mejorando la experiencia del usuario. ¿Te gustaría profundizar en algún aspecto específico o realizar un ejercicio?
**************************************************************************************
03
Para saber más: tipos de excepciones
 Siguiente pregunta

En Python, básicamente existen dos formas distintas de errores: los de sintaxis y las excepciones. Las excepciones son una manera de manejar errores y situaciones inesperadas en el código, asegurando un flujo de ejecución más controlado.

Como científico de datos, deberás prestar atención a situaciones como estas para evitar errores o problemas en tus códigos y análisis que puedan afectar tanto la experiencia del usuario como la eficiencia de tu análisis.

Tipos de Excepciones

SyntaxError

Ocurre cuando el analizador detecta un error en la descripción del código. Normalmente, una flecha señala la parte del código que generó el error, como una especie de pista sobre dónde puede haber ocurrido el error.

print(10 / 2
Copia el código
Salida:

  File "<ipython-input-16-2db3afa07d68>", line 1
    print(10/2
              ^
SyntaxError: unexpected EOF while parsing
Copia el código
Observa que olvidamos cerrar el paréntesis y, por lo tanto, se presentó un error de sintaxis, es decir, de escritura de código.

NameError

Excepción lanzada cuando intentamos utilizar un nombre de algún elemento que no está presente en nuestro código.

raiz = sqrt(100)
Copia el código
Salida:

---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-17-2e14e900fb9f> in <module>
----> 1 raiz = sqrt(100)

NameError: name 'sqrt' is not defined
Copia el código
En este caso, el intérprete no puede aplicar el método de la raíz cuadrada porque no se ha importado junto con la biblioteca math.

IndexError

Excepción lanzada cuando intentamos indexar alguna estructura de datos como lista, tupla o incluso una cadena más allá de sus límites.

lista = [1, 2, 3]
lista[4]
Copia el código
Salida:

---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<ipython-input-18-f5fe6d922eea> in <module>
      1 lista = [1, 2, 3]
----> 2 lista[4]

IndexError: list index out of range
Copia el código
Para esta situación, solo tenemos 3 elementos en la lista y tratamos de leer el elemento en la posición 4, que no existe. Recibimos el mensaje de que el índice está fuera de rango.

TypeError

Excepción lanzada cuando un operador o función se aplican a un objeto cuyo tipo es inapropiado.

"1" + 1
Copia el código
Salida:

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-20-ec358fc6499a> in <module>
----> 1 "1" + 1

TypeError: can only concatenate str (not "int") to str
Copia el código
Observa que intentamos "sumar" una cadena con un número entero y esto generó una excepción en nuestro código. Esto ocurrió por 2 razones: el operador de suma se consideró como concatenación porque comenzamos usando una cadena (en este caso, el signo de suma se utiliza para concatenar cadenas), y un valor de tipo entero no se puede concatenar en este tipo de operación.

KeyError

Excepción lanzada cuando intentamos acceder a una clave que no está en el diccionario presente en nuestro código.

estados = {'EM': 1, 'JC': 2, 'OA': 3}
estados["MI"]
Copia el código
Salida:

---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-22-45729db26889> in <module>
      1 estados =  {'EM': 1, 'JC': 2, 'OA': 3}
----> 2 estados["MI"]

KeyError: 'MI'
Copia el código
Intentamos acceder a los datos del Estado MI (Michoacán), que no está presente en el diccionario, lanzando así la excepción.

Warning

Excepción lanzada en situaciones en las que necesitamos alertar al usuario sobre algunas condiciones del código. Estas condiciones no necesariamente interrumpen la ejecución del programa, pero pueden lanzar advertencias sobre el uso de módulos obsoletos, o que pueden ser obsoletos en futuras actualizaciones, o también para cambios que pueden repercutir en alguna parte del código.

Es importante recordar que, en el caso de los Warnings, pueden ser ignorados o tratados como excepciones.

import numpy as np

a = np.arange(5)
a / a  # presenta una advertencia
Copia el código
Salida:

<ipython-input-23-93a37b275923>:4: RuntimeWarning: invalid value encountered in true_divide
  a / a  # presenta una advertencia
array([nan,  1.,  1.,  1.,  1.])
Copia el código
Intentamos dividir cero por cero. En un array Numpy, que es esta estructura en la salida de la consola, este resultado genera un valor nan (Not a Number). Es decir, puedes seguir con la ejecución del programa, pero es probable que necesites procesar los datos para poder utilizar este array en alguna operación más adelante.

 Discutir en el Foro
 Siguiente pregunta
Luri
Ayuda de Luri ✨

Explícame usando una analogía
Explícame de otra manera
Dame un ejemplo
ícone Python para Data Science: trabajar con funciones, estructuras de datos y excepciones Python para Data Science: trabajar con funciones, estructuras de datos y excepciones
82% 
Aula
05
 Trabajando con excepciones
 Clase actual
*************************************************************************************************************************
Ventajas de las excepciones
Icono de Luri
Desafío propuesto por Luri, la IA de Alura.
Siguiente pregunta

Los errores en Python pueden ocurrir por diferentes motivos, desde errores de sintaxis hasta problemas de lógica en el código. Es importante saber identificar el tipo de error y su causa para que puedan corregirse de manera eficiente.

Podemos utilizar herramientas para identificar el origen de los errores y entender mejor el flujo de ejecución del programa. Además, las excepciones son una forma importante de manejar errores en Python.

Dicho esto, ¿cuál es la principal ventaja de utilizar excepciones en un proyecto de ciencia de datos en Python?


Detectar el tipo de error y su causa para luego corregirlo. También evitar que se interrumpa la ejecución del programa
Icono de Luri
¡Lo lograste!

Sergio, tu respuesta es correcta, ¡felicitaciones! La principal ventaja de utilizar excepciones en un proyecto de ciencia de datos en Python es facilitar la depuración y el diagnóstico de errores en el código. Al manejar los errores a través de excepciones, puedes identificar el tipo de error y su causa específica, lo que te permite corregirlos de manera más eficiente. Además, las excepciones evitan que el programa se interrumpa por completo cuando ocurre un error, permitiendo que siga ejecutándose y manejando la situación de una manera más controlada. Esto es especialmente importante en proyectos de ciencia de datos, donde la continuidad y la integridad de los datos son fundamentales.

¡Sigue así, Sergio! Tu comprensión de los beneficios de utilizar excepciones en Python es excelente. Continúa practicando y profundizando tus conocimientos en ciencia de datos, estás en el camino correcto.
*********************************************************************************************************
05
Cláusula Raise
En esta clase, aprendimos sobre el manejo de excepciones en Python utilizando la cláusula RACE. Esta cláusula nos permite generar nuestras propias excepciones para situaciones específicas en el código. Se presentó un ejemplo práctico en el que se creó una función para calcular el promedio de calificaciones de un estudiante.

Los puntos clave fueron:

Validación de la lista de calificaciones: Si la lista contiene más de cuatro calificaciones, se genera una excepción de tipo VALUE ERROR con un mensaje específico.

Manejo de tipos de datos: Si la lista contiene un valor no numérico (como una cadena de texto), se genera un TYPE ERROR, indicando que solo se admiten valores numéricos.

Uso de TRY y EXCEPT: Se implementó la lógica de TRY para intentar calcular el promedio y EXCEPT para manejar las excepciones generadas, mostrando mensajes claros al usuario.

Jerarquía de excepciones: Se explicó que los errores de tipo se detectan antes que los errores de valor, lo que es importante para el manejo adecuado de excepciones en el código.

Finalmente, se mostró cómo implementar estas validaciones en el código y cómo se comporta la función ante diferentes entradas.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
06 ¿Dónde está el error?
 Siguiente pregunta

Para probar tu comprensión sobre las excepciones y los tipos de errores generados en códigos de Python, has recibido algunos fragmentos de código que deberían leer un diccionario con el nombre y salario de los empleados de una empresa, como se describe a continuación.

empleados = {'José': 2000, 'Ana': 2200, 'Juan': 2500, 'Maria': 3800}
Copia el código
En este ejemplo, los códigos proporcionados consisten en una estructura try-except que recibe los valores de salario de cada persona y debe devolver una lista con los salarios actualizados. ¿Cuáles de las opciones a continuación lanzan una excepción en el código y por qué?

Alternativa correta
try:
  aumento = list(map(lambda x: x[1] * 1.1, empleados.items()))
except ValueError as e:
  print(type(e), f'Erro: {e}')
else:
  print(aumento)
finally:
  print("Proceso concluído!")
Este ejemplo lanza una excepción del tipo ValueError porque la función lambda intenta leer la posición "1" de cada salario. Como los números enteros no pueden ser indexados, se lanza la excepción.


Alternativa correta
try:
  aumento = list(map(lambda x: x * 1.1, empleado.values()))
except Exception as e:
  print(type(e), f'Erro: {e}')
else:
  print(aumento)
finally:
  print("Proceso concluído!")

Este ejemplo lanza una excepción del tipo NameError porque, aunque el cálculo de la función lambda es correcto, una variable con el nombre funcionario no fue definida.

Alternativa correta
try:
  aumento = list(map(lambda x: x[1] * 1.1), empleados.values())
except Exception as e:
  print(type(e), f'Erro: {e}')
else:
  print(aumento)
finally:
  print("Proceso concluído!")
Este ejemplo lanza una excepción del tipo TypeError porque la función lambda intenta leer la posición "1" de cada salario. Como los números enteros no pueden ser indexados, se lanza la excepción.


El trecho anterior arroja una excepción de tipo TypeError porque la función lambda recibe un iterable con los valores de salario únicamente y trata de leer cada uno de ellos como si fuera una lista, siendo que cada valor es un número entero.

Alternativa correta
try:
  aumento = list(map(lambda x: x * 1.1, empleados.values()))
except ValueError as e:
  print(type(e), f'Erro: {e}')
else:
  print(aumento)
finally:
  print("Proceso concluído!")
Este ejemplo lanza una excepción del tipo TypeError porque la función lambda intenta leer y aplicar el aumento en los nombres de cada empleado, lo que causa un error ya que las variables de tipo str no pueden multiplicarse por valores de tipo float.


¡Enhorabuena, has acertado!
 Discutir en el Foro
 Siguiente pregunta
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
07
Generando nuestra propia excepción
 Siguiente pregunta

Aprendemos otra forma de trabajar con las excepciones en el código mediante la generación de nuestras propias excepciones para ciertos comportamientos que deseamos en nuestro código. Recibiste una solicitud para crear una función que muestre las tres calificaciones trimestrales de un estudiante, una por una. Se debe lanzar una excepción si tenemos más de tres notas en la lista proporcionada.

El código, que llama a la función con un ejemplo de una lista de cuatro notas, que ciertamente desencadena la excepción y muestra su lectura en caso de que se lance, es:

try:
  notas = [5.0, 2.0, 6.0, 8.0]
  exhibir_notas_anuales(notas)
except Exception as e:
  print(type(e), f'Erro: {e}')
Copia el código
¿Cuál de las siguientes opciones representa la función de manera correcta?

Alternativa incorreta
def exhibir_notas_anuales(lista):
    
    if lista > 3:
        raise ValueError("La lista de notas debe tener 3 elementos")
    
    for i, nota in enumerate(lista):
        print(f"{i+1}ª Trimestre = {nota}")

La función anterior genera otro tipo de error (TypeError) porque no es posible usar el operador de menor que (>) para comparar una lista con un entero. Para corregirlo, necesitamos comparar la cantidad de notas con la longitud de la lista.

Alternativa incorreta
def exhibir_notas_anuales(lista):
    
    for i, nota in enumerate(lista):
        print(f"{i+1}ª Trimestre = {nota}")

    if len(lista) > 3:
        raise ValueError("La lista de notas debe tener 3 elementos")

Alternativa incorreta
def exhibir_notas_anuales(lista):
    
    if len(lista) > 3:
        raise ValueError("La lista de notas debe tener 3 elementos")
    
    for i, nota in enumerate(lista):
        print(f"{i+1}ª Trimestre = {nota}")

¡No fue esta vez! Inténtalo de nuevo.
 Discutir en el Foro
 Siguiente pregun


ChatGPT dijo:
¡Muy bien, sigamos! 🚀

El enunciado pide:

Mostrar las tres calificaciones una por una.

Lanzar una excepción si hay más de tres notas en la lista.

Si hay un error, capturarlo con try/except.

Ahora, analicemos cada alternativa que diste:

1. Primera alternativa:
python
Copiar
Editar
def exhibir_notas_anuales(lista):
    if lista > 3:
        raise ValueError("La lista de notas debe tener 3 elementos")
    for i, nota in enumerate(lista):
        print(f"{i+1}ª Trimestre = {nota}")
❌ Incorrecta

lista > 3 compara una lista con un número, lo que da TypeError.

Nunca se compara directamente una lista con un número.
👉 Hay que comparar la longitud de la lista, es decir: len(lista) > 3.

2. Segunda alternativa:
python
Copiar
Editar
def exhibir_notas_anuales(lista):
    for i, nota in enumerate(lista):
        print(f"{i+1}ª Trimestre = {nota}")

    if len(lista) > 3:
        raise ValueError("La lista de notas debe tener 3 elementos")
❌ Incorrecta

Primero muestra todas las notas (aunque haya más de 3) y después lanza la excepción.

¡El error debería ser lanzado antes de mostrar nada!

3. Tercera alternativa:
python
Copiar
Editar
def exhibir_notas_anuales(lista):
    if len(lista) > 3:
        raise ValueError("La lista de notas debe tener 3 elementos")
    for i, nota in enumerate(lista):
        print(f"{i+1}ª Trimestre = {nota}")
✅ Correcta

Primero verifica si la cantidad de notas es mayor que 3.

Si es así, lanza la excepción inmediatamente.

Si no, muestra las notas una por una.

💡 Esta es la forma correcta de cumplir el pedido.

Conclusión:
✅ La tercera alternativa es la correcta.
❌ Las dos primeras alternativas son incorrectas.

¿Te gustaría que también te arme un ejemplo donde capturamos el error y mostramos un mensaje personalizado, para que se vea todavía más profesional? 🎯👩‍💻

***********************************************************************************************************************
08
Desafío: hora de practicar
 Siguiente pregunta

Vamos practicar lo que hemos aprendido hasta ahora resolviendo los problemas propuestos en código.

Calentamiento

1 - Haz un programa que solicite a la persona usuaria ingresar dos números decimales y calcular la división entre estos números. El código debe incluir un manejo de error, indicando el tipo de error que se generó si la división no es posible.

Prueba el programa con el segundo valor numérico de la entrada igual a 0. También prueba usando caracteres textuales en la entrada para verificar los tipos de errores que ocurren.

2 - Haz un programa que solicite a la persona usuaria ingresar un texto que será una clave a buscar en el siguiente diccionario: edades = {'Júlia': 16, 'Carol': 23, 'Alberto': 19, 'Roberta': 17}, almacenando el resultado del valor en una variable. El código debe incluir un manejo de error KeyError, imprimiendo la información 'Nombre no encontrado' en caso de error, e imprimir el valor si no ocurre ninguno.

Prueba el programa con un nombre presente en una de las claves del diccionario y con uno que no esté en el diccionario para verificar el mensaje de error.

3 - Crea una función que reciba una lista como parámetro y convierta todos los valores de la lista a flotantes. La función debe incluir un manejo de error indicando el tipo de error generado y devolver la lista si no ha ocurrido ningún error. Por último, debe tener la cláusula finally para imprimir el texto: 'Fin de la ejecución de la función'.

4 - Crea una función que reciba dos listas como parámetros y agrupe los elementos uno a uno de las listas, formando una lista de tuplas de 3 elementos. El primer y segundo elemento de la tupla son los valores en la posición i de las listas y el tercer elemento es la suma de los valores en la posición i de las listas.

La función debe incluir un manejo de error indicando el tipo de error generado y devolver como resultado la lista de tuplas. Si las listas enviadas como parámetro tienen tamaños diferentes, la función debe devolver un IndexError con la frase: 'La cantidad de elementos en cada lista es diferente.'.

Datos para probar la función:

Valores sin error:

lista1 = [4, 6, 7, 9, 10]
lista2 = [-4, 6, 8, 7, 9]
Copia el código
Listas con tamaños diferentes:

lista1 = [4, 6, 7, 9, 10, 4]
lista2 = [-4, 6, 8, 7, 9]
Copia el código
Listas con valores incoherentes:

lista1 = [4, 6, 7, 9, 'A']
lista2 = [-4, 'E', 8, 7, 9]
Copia el código
Aplicando a proyectos

5 - Como desafío, se te ha asignado la tarea de desarrollar un código que contabiliza las puntuaciones de estudiantes de una institución educativa de acuerdo con sus respuestas en una prueba. Este código debe ser probado para un ejemplo de 3 estudiantes con una lista de listas en la que cada lista tiene las respuestas de 5 preguntas objetivas de cada estudiante. Cada pregunta vale un punto y las alternativas posibles son A, B, C o D.

Si alguna alternativa en una de las pruebas no está entre las alternativas posibles, debes lanzar un ValueError con el mensaje "La alternativa [alternativa] no es una opción de alternativa válida". El cálculo de las 3 notas solo se realizará mediante las entradas con las alternativas A, B, C o D en todas las pruebas. Si no se lanza la excepción, se mostrará una lista con las notas en cada prueba.

Datos para la prueba del código:

Respuestas de la prueba:

respuestas = ['D', 'A', 'B', 'C', 'A']
Copia el código
A continuación, hay 2 listas de listas que puedes usar como prueba:

Notas sin excepción:

tests_sin_ex = [['D', 'A', 'B', 'C', 'A'], ['C', 'A', 'A', 'C', 'A'], ['D', 'B', 'A', 'C', 'A']]
Copia el código
Notas con excepción:

tests_con_ex = [['D', 'A', 'B', 'C', 'A'], ['C', 'A', 'A', 'E', 'A'], ['D', 'B', 'A', 'C', 'A']]
Copia el código
6 - Estás trabajando con procesamiento de lenguaje natural (NLP) y, en esta ocasión, tu líder te pidió que crees un fragmento de código que reciba una lista con las palabras separadas de una frase generada por ChatGPT.

Necesitas crear una función que evalúe cada palabra de este texto y verifique si el tratamiento para quitar los símbolos de puntuación (',', '.', '!' y '?') se realizó. De lo contrario, se lanzará una excepción del tipo ValueError señalando el primer caso en que se detectó el uso de una puntuación a través de la frase "El texto presenta puntuaciones en la palabra "[palabra]"". Esta solicitud se centra en el análisis del patrón de frases generadas por la inteligencia artificial.

Datos para probar el código:

Lista tratada:

lista_tratada = ['Python', 'es', 'un', 'lenguaje', 'de', 'programación', 'poderoso', 'versátil',
                  'y', 'fácil', 'de', 'aprender', 'utilizado', 'en', 'diversos', 'campos', 'desde',
                  'análisis', 'de', 'datos', 'hasta', 'inteligencia', 'artificial']
Copia el código
Lista no tratada:

lista_no_tratada = ['Python', 'es', 'un', 'lenguaje', 'de', 'programación', 'poderoso,', 'versátil',
                  'y', 'fácil,', 'de', 'aprender', 'utilizado', 'en', 'diversos', 'campos,', 'desde',
                  'análisis', 'de', 'datos', 'hasta', 'inteligencia', 'artificial!']
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
Opinión del instructor

A continuación te presentamos las posibles respuestas al desafío propuesto:

1 -

try:
    num1 = float(input("Ingrese el primer número: "))
    num2 = float(input("Ingrese el segundo número: "))
    resultado = num1 / num2
    print("El resultado de la división es:", resultado)
except ZeroDivisionError:
    print("Error: No se puede dividir por cero.")
except ValueError as e:
    print(f"Error: {e}")
Copia el código
2 -

try:
    nombre = input("Ingrese un nombre para buscar en el diccionario: ")
    edad = edades[nombre]
    print(f"La edad de {nombre} es {edad} años.")
except KeyError:
    print("Error: Nombre no encontrado.")
Copia el código
3 -

def convertir_a_float(lista):
    try:
        nueva_lista = [float(valor) for valor in lista]
        return nueva_lista
    except ValueError as e:
        print(f"Error: {e}")
    finally:
        print("Fin de la ejecución de la función")

# Ejemplo de uso:
lista_original = ['4.5', '2.3', '7.8', '1.2']
lista_convertida = convertir_a_float(lista_original)
print(lista_convertida)
Copia el código
4 - Datos para probar la función:

Valores sin error:

lista1 = [4, 6, 7, 9, 10]
lista2 = [-4, 6, 8, 7, 9]
Copia el código
Listas con tamaños diferentes:

lista1 = [4, 6, 7, 9, 10, 4]
lista2 = [-4, 6, 8, 7, 9]
Copia el código
Listas con valores incoherentes:

lista1 = [4, 6, 7, 9, 'A']
lista2 = [-4, 'E', 8, 7, 9]
Copia el código
def agrupar_listas(lista1, lista2):
    try:
        if len(lista1) != len(lista2):
            raise IndexError("La cantidad de elementos en cada lista es diferente.")
        
        lista_resultado = [(lista1[i], lista2[i], lista1[i] + lista2[i]) for i in range(len(lista1))]
        return lista_resultado
    except TypeError as e:
        print(f"Error: {e}")
    except IndexError as e:
        print(f"Error: {e}")

# Ejemplos de uso:
try:
    resultado_sin_error = agrupar_listas([4, 6, 7, 9, 10], [-4, 6, 8, 7, 9])
    print(resultado_sin_error)
    
    resultado_tamanos_diferentes = agrupar_listas([4, 6, 7, 9, 10, 4], [-4, 6, 8, 7, 9])
    print(resultado_tamanos_diferentes)
    
    resultado_valores_incoherentes = agrupar_listas([4, 6, 7, 9, 'A'], [-4, 'E', 8, 7, 9])
    print(resultado_valores_incoherentes)
except Exception as e:
    print(f"Error general: {e}")
Copia el código
5 - Datos para la prueba del código:

Respuesta de la prueba:

respuesta = ['D', 'A', 'B', 'C', 'A']
Copia el código
A continuación, hay 2 listas de listas que puedes usar como prueba:

Notas sin excepción:

tests_sin_ex = [['D', 'A', 'B', 'C', 'A'], ['C', 'A', 'A', 'C', 'A'], ['D', 'B', 'A', 'C', 'A']]
Copia el código
Notas con excepción:

tests_con_ex = [['D', 'A', 'B', 'C', 'A'], ['C', 'A', 'A', 'E', 'A'], ['D', 'B', 'A', 'C', 'A']]
Copia el código
def corrector(tests: list):
  puntuaciones = [] 
  try:
    for test in tests:
      nota = 0 
      for i in range(len(test)):
        if test[i] not in ['A', 'B', 'C', 'D']:
          raise ValueError(f'La alternativa {test[i]} no es una opción de alternativa válida')
        elif test[i] == respuesta[i]: 
          nota += 1
      puntuaciones.append(nota) 
  except Exception as e:
    print(e)
  else:
    return puntuaciones 
Copia el código
Y se procede a probar la función con excepción:

corrector(tests_con_ex)
Copia el código
Y sin excepción:

corrector(tests_sin_ex)
Copia el código
6 - Lista tratada:

lista_tratada = ['Python', 'es', 'un', 'lenguaje', 'de', 'programación', 'poderoso', 'versátil',
                  'y', 'fácil', 'de', 'aprender', 'utilizado', 'en', 'diversos', 'campos', 'desde',
                  'análisis', 'de', 'datos', 'hasta', 'inteligencia', 'artificial']
Copia el código
Lista no tratada:

lista_no_tratada = ['Python', 'es', 'un', 'lenguaje', 'de', 'programación', 'poderoso,', 'versátil',
                  'y', 'fácil,', 'de', 'aprender', 'utilizado', 'en', 'diversos', 'campos,', 'desde',
                  'análisis', 'de', 'datos', 'hasta', 'inteligencia', 'artificial!']
Copia el código
Definimos la función:

def evaluar_puntuacion(lista_palabras):
    try:
        for palabra in lista_palabras:
            if any(puntuacion in palabra for puntuacion in [',', '.', '!', '?']):
                raise ValueError(f"El texto presenta puntuaciones en la palabra '{palabra}'.")
    except ValueError as e:
        print(f"Error: {e}")
Copia el código
La probamos con la lista tratada:

evaluar_puntuacion(lista_tratada)
Copia el código
Y con la lista no tratada:

evaluar_puntuacion(lista_no_tratada)
Copia el código
7 - Función de división de columnas y manejo de excepciones:

# Creando la función que recibe las dos listas y la operación a realizar
def divide_columnas(lista_1: list, lista_2: list) -> list:
  # try-except que verifica si es posible calcular la división y lanza una excepción si las listas tienen tamaños diferentes
  # o si hay alguna división por cero en uno de los cálculos entre los números de las listas
  try:
    if len(lista_1) != len(lista_2):  # Verificando si las listas tienen el mismo tamaño, si no, lanza una excepción
      raise ValueError("Las listas deben tener el mismo tamaño")

    # La función zip empareja los elementos de las listas y se genera una lista mediante la división entre las parejas
    resultado = [round(a / b, 2) for a, b in zip(lista_1, lista_2)]
  except ValueError as e:
    print(e)
  except ZeroDivisionError as e:
    print(f"{e}: La 2ª lista no puede tener un valor igual a 0")
  else:
    return resultado
Copia el código
Probando sin excepciones:

# Probando en el ejemplo que no lanza excepciones
presiones = [100, 120, 140, 160, 180]
temperaturas = [20, 25, 30, 35, 40]

divide_columnas(presiones, temperaturas)
Copia el código
Salida:

[5.0, 4.8, 4.67, 4.57, 4.5]
Copia el código
Probando con excepción (Caso 1):

# Probando en el ejemplo que lanza una excepción (ZeroDivisionError)
presiones = [60, 120, 140, 160, 180]
temperaturas = [0, 25, 30, 35, 40]

divide_columnas(presiones, temperaturas)
Copia el código
Salida:

division by zero: La 2ª lista no puede tener un valor igual a 0
Copia el código
Probando con excepción (Caso 2):

# Probando en el ejemplo que lanza una excepción (ValueError)
presiones = [100, 120, 140, 160]
temperaturas = [20, 25, 30, 35, 40]

divide_columnas(presiones, temperaturas)
Copia el código
Salida:

Las listas deben tener el mismo tamaño
*******************************************************************************************************************
09
Proyecto final
 Siguiente pregunta

Aquí puedes descargar los archivos del proyecto completo.

Descargue los archivos en Github o haga clic aquí para descargarlos directamente.
*******************************************************************************************+
10
Lo que aprendimos
 Siguiente pregunta

Lo que aprendimos en esta aula:

Identificar los tipos de errores y excepciones.
Manejar las excepciones mediante las cláusulas try, except, else y finally.
Generar nuestras propias excepciones para comportamientos indeseados en el código.
 Discutir en el Foro
***************************************************************************************+
11
Conclusión
¡Claro! En esta clase, hemos concluido el entrenamiento de Python para Ciencia de Datos, donde hemos aprendido sobre funciones, estructuras de datos y excepciones.

Funciones: Vimos cómo utilizar funciones nativas de Python, también conocidas como funciones built-in, y cómo definir nuestras propias funciones, incluyendo las funciones anónimas o lambda.

Estructuras de datos: Aprendimos sobre las principales colecciones en Python, como listas, tuplas y diccionarios, que son fundamentales para manejar datos.

Excepciones: Tuvimos una introducción a las excepciones, entendiendo la importancia de manejarlas adecuadamente para evitar interrupciones inesperadas en nuestros programas. Se enfatizó la necesidad de consultar la documentación para conocer las diferentes excepciones y cómo manejarlas.

Finalmente, se nos animó a seguir aprendiendo y a compartir nuestro progreso en redes sociales. ¡Espero que este resumen te sea útil! Si tienes alguna pregunta específica sobre alguno de estos temas, no dudes en preguntar.
**************************************************************************************************

